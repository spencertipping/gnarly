#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

meta::meta('datatypes::attribute', <<'__PYmyPgg2sMijXksysuPrJU0k2SAh5zzFu2hvd7hDcoU');
meta::define_form 'attribute', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "attribute::$name";
  *{$name} = sub {
    associate("attribute::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    retrieve("attribute::$name");
  };
};
__PYmyPgg2sMijXksysuPrJU0k2SAh5zzFu2hvd7hDcoU

meta::meta('datatypes::bootstrap', <<'__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM');
meta::define_form 'bootstrap', sub {};
__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM

meta::meta('datatypes::code', <<'__OEWZ93LGHT8yOiO/06UyIrAiKTXnAbI7tYl7+93uAT0');
meta::define_form 'code', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "code::$name";
  *{$name} = sub {
    edit("code::$name");
  };
};
__OEWZ93LGHT8yOiO/06UyIrAiKTXnAbI7tYl7+93uAT0

meta::meta('datatypes::configuration', <<'__my6exSOOfpxIJLIUfmSVVMUaquAgbayoNBj9guBwbYU');
meta::define_form 'configuration', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "configuration::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__my6exSOOfpxIJLIUfmSVVMUaquAgbayoNBj9guBwbYU

meta::meta('datatypes::data', <<'__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U');
meta::define_form 'data', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "data::$name";
  *{$name} = sub {
    associate("data::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    retrieve("data::$name");
  };
};
__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U

meta::meta('datatypes::function', <<'__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0');
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "function::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0

meta::meta('datatypes::internal_function', <<'__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong');
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong

meta::meta('datatypes::library', <<'__3RHc2q2OKjeHL1QRq6jhHHCeSrNLDPWTwSax7MclXRE');
meta::define_form 'library', sub {
  eval $_[1];
  warn $@ if $@;
};
__3RHc2q2OKjeHL1QRq6jhHHCeSrNLDPWTwSax7MclXRE

meta::meta('datatypes::list-type', <<'__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w');
meta::define_form '_list_type', sub {
  my ($outer_name, $outer_value) = @_;
  $externalized_functions{$outer_name} = "_list_type::$outer_name";
  
  *{$outer_name} = sub {
    associate("${outer_value}::$_", '') for @_;
  };

  meta::define_form $outer_value, sub {
    my ($name, $value) = @_;
    $externalized_functions{$name} = "${outer_value}::$name";
    *{$name} = sub {
      my ($command, @xs) = @_;
      my $xs = join "\n", @xs;
      return grep length, split /\n/, retrieve("${outer_value}::$name")               if $command eq 'items';
      associate("${outer_value}::$name", retrieve("${outer_value}::$name") . "\n$xs") if $command eq 'add' || $command eq '<<';
      edit("${outer_value}::$name")                                                   if $command eq 'edit';
      return retrieve("${outer_value}::$name");
    };
  };
};
__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w

meta::meta('datatypes::vim-highlighter', <<'__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0');
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0

meta::meta('internal::runtime', <<'__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA');
meta::define_form 'internal', \&meta::meta::implementation;
__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA

meta::_list_type('issue', <<'__SlAoRtBw4giLcCWr6AYpgwvwPXq1Yk1ekfMyvJ0EnT8');
issue
__SlAoRtBw4giLcCWr6AYpgwvwPXq1Yk1ekfMyvJ0EnT8

meta::_list_type('list', <<'__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk');
list
__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk

meta::attribute('module-api-version', <<'__0P9ZdLaqUs9WK+pZIYQMAyqGCpGjUS9/6Pdo9rvgBfY');
1.0
__0P9ZdLaqUs9WK+pZIYQMAyqGCpGjUS9/6Pdo9rvgBfY

meta::attribute('module-name', <<'__5G+SI2c5FHz3DmbOkWln/arXb69WOp25fAg3CiSh5XQ');
optimize
__5G+SI2c5FHz3DmbOkWln/arXb69WOp25fAg3CiSh5XQ

meta::attribute('module-revision', <<'__X+zrZv/IbzjZUnhsbWlsecLbwjndTpG0ZynXOif7V+k');
0
__X+zrZv/IbzjZUnhsbWlsecLbwjndTpG0ZynXOif7V+k

meta::bootstrap('initialization', <<'__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc');
#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc

meta::code('cached-dependencies', <<'__r58/DMCjq66nPnOpcuqaB7L0z7Jpfj2e3BSVc74uHWM');
This will be overwritten when you type load-dependencies.
__r58/DMCjq66nPnOpcuqaB7L0z7Jpfj2e3BSVc74uHWM

meta::code('integration-tests', <<'__Q4ZqcS3Gx3zaAHh8IKp8z9BT+IJxx4qAJ/5ZT2Y8kDU');
Integration tests. These are run after your code is loaded and the unit tests have been run.
__Q4ZqcS3Gx3zaAHh8IKp8z9BT+IJxx4qAJ/5ZT2Y8kDU

meta::code('source', <<'__FuOhCD/UKkMAyRJLWLoqd4RuFlPJi7/MGub4MIJyZQ8');
Function Optimization | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license

This module addresses one of the deficiencies in Gnarly's interpreter; namely, that the beta-expander is ridiculously slow. You can use the functions in this
module to JIT to Perl functions, which should be many orders of magnitude faster. The only downside is that the resulting functions are not first-class
beta-expanders in the sense that you can't disassemble them using !!< and !!>. However, it wouldn't make much sense to disassemble an already-optimized
function.

Translating into Perl.
At the base layer, all we're doing is creating a faster and slightly smarter version of fn. (You can also '> it to get the corresponding qn.) Right now, the
semantics of fn are to eval the parameter, put it into a placeholder, and then beta-expand it into the expansion, evaluating the result. We lose speed in a
couple of ways, but the most significant it this: the expansion could be another fn, in which case we should compile the second fn up-front as opposed to
waiting until we have the first parameter. Since Perl allows anonymous closures to be created, we can encode this in a straightforward way.

Note that we must do some inlining through the global symbol table if we want to precompile inner functions. This isn't horrible, but it does mean that the
function becomes pure since all of the free symbols are baked in. It also means that it matters when you do the optimization; all of the symbols that are
referenced in the function must have their proper values when you optimize it. Finally, there's one more consideration. Recursive functions obviously won't do
the right thing because as soon as they hit the recursive symbol they'll be back in unoptimized code. For now you have to define recursive functions by using
the y/z combinator (see core).

Because the core language is fairly straightforward and all values can be inspected, translating these forms into Perl is trivial at the high level.
Compositions can be translated directly (optionally inlined, though I'm not doing that yet), beta-expanders can be encoded as Perl subroutines (wrapped in the
lambda() constructor), and other expressions can be encoded as inlined cons-evaluators if they are going to be evaluated. (The naive approach would encode them
as cons-cells that would be evaluated by the functions they were passed to. With some work, however, you can pre-expand the cons logic to avoid allocating
memory.)

  (def opt-beta (fn b ()))
  (def opt-comp (fn c ()))
  (def opt-cons (fn c ()))
  (def opt-atom (fn a ()))

  (def optimize (fn f (cond (((@? f) (opt-beta f)) ((o? f) (opt-comp f))
                             ((*? f) (opt-cons f)) (k      (opt-atom f))))))
__FuOhCD/UKkMAyRJLWLoqd4RuFlPJi7/MGub4MIJyZQ8

meta::code('tests', <<'__pUlbKLBwH0shnUUThu2z/3EhVnuOvhbfCOedvgFOifU');
Module-specific unit tests go here. These will be run when you type :unit, and when you try to load the module as a dependency.
__pUlbKLBwH0shnUUThu2z/3EhVnuOvhbfCOedvgFOifU

meta::configuration(':check', <<'__KvsssAe/QdPPsO6QGorfBgTAacCYF0TyU/r2trjV79o');
shell::initialize_symbol_table();
delete $transient{'last-failure'};

eval {shell::load_quietly('cached-dependencies', 'source', 'tests', 'integration-tests')};
terminal::message('error', $@) if $@;
'';     # Return silence on success.
__KvsssAe/QdPPsO6QGorfBgTAacCYF0TyU/r2trjV79o

meta::configuration(':export', <<'__btFu4SltjXa0eLKiqqrtZ+F3l4l/2XzUEaZXRE0jgyU');
&{':check'}();
return join("\n", retrieve('code::cached-dependencies', 'code::source')) . "\n\n" unless $transient{'last-failure'};
terminal::message('error', $transient{'last-failure'});
return '';
__btFu4SltjXa0eLKiqqrtZ+F3l4l/2XzUEaZXRE0jgyU

meta::configuration(':main', <<'__/vfwogrZnxJ3KpphPp94bXOA6L9YLCBkmxZkE/4LRUc');
shell::initialize_symbol_table();
run('cached-dependencies', 'source');
__/vfwogrZnxJ3KpphPp94bXOA6L9YLCBkmxZkE/4LRUc

meta::configuration(':test', <<'__LdPLavysWyPM5r4ze8pyazYiWAfGW+7BSHx7ItKQOfI');
&{':main'}();
run('tests', 'integration-tests');
__LdPLavysWyPM5r4ze8pyazYiWAfGW+7BSHx7ItKQOfI

meta::data('default-action', <<'__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc');
shell
__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc

meta::data('meta-associations', <<'__NDlbniBIqlUMMFt2j+H/M2C23PT4iOuVEABcA+vGo6U');
^function:: .pl
^library:: .pl
^internal_function:: .pl
^meta:: .pl
^bootstrap:: .pl
^configuration:: .pl
^code:: .gnarly
^vim_highlighter:: .vim
__NDlbniBIqlUMMFt2j+H/M2C23PT4iOuVEABcA+vGo6U

meta::function('add-to', <<'__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q');
my ($filename) = @_;
my @members = grep /^implementation::/, keys %data;

for (@members) {
  my $destination_name = basename($_);
  open my($handle), "| $filename import $destination_name" or messages::error("Attribute $_ could not be written.");
  print $handle retrieve($_);
  close $handle;
}
__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q

meta::function('api-name', <<'__qA8PQrovsL6EIw5iatzFboQXAdvl064VoxzO6b8D3oQ');
&{'module-name'}() . ':' . &{'module-api-version'}();
__qA8PQrovsL6EIw5iatzFboQXAdvl064VoxzO6b8D3oQ

meta::function('attributes', <<'__SHSGXpl5WufcHc7hGxs0XPxlKSgo0XQ752HpjI4rgRg');
grep /^attribute::/, sort keys %data;
__SHSGXpl5WufcHc7hGxs0XPxlKSgo0XQ752HpjI4rgRg

meta::function('cat', <<'__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk');
my ($name) = @_;
$data{$name};
__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk

meta::function('clone', <<'__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY

meta::function('cp', <<'__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4

meta::function('create', <<'__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc');
my ($name, $value) = @_;
messages::error("Attribute $name already exists.") if grep {$_ eq $name} keys %data;
if ($value) {
  associate($name, $value);
} else {
  associate($name,'');
  edit ($name);
}
__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc

meta::function('edit', <<'__wmkQAgPhtPrNx2Sc88M1MNK4gG2sn/UGqsnAtRv6ksY');
my ($name, %options) = @_;

my $meta_extension = join '', grep {
  my $s = $_;
  $s =~ s/\s.*$//;
  $name =~ /$s/
} split /\n/, &{'meta-associations'}();

$meta_extension =~ s/^.*\s//;
chomp $meta_extension;

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $meta_extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
save();
__wmkQAgPhtPrNx2Sc88M1MNK4gG2sn/UGqsnAtRv6ksY

meta::function('exists', <<'__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk');
my $name = shift;
grep {$_ eq $name} keys %data;
__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk

meta::function('full-name', <<'__X5DqVkiY6nnaoUwhy1rWlslSD2vlNZ5zkbCZRfb1ITI');
&{'api-name'}() . ':' . &{'module-revision'}();
__X5DqVkiY6nnaoUwhy1rWlslSD2vlNZ5zkbCZRfb1ITI

meta::function('grab', <<'__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8');
my ($filename, @attribute_names) = @_;
associate("implementation::$_", `$filename cat $_`) for @attribute_names;
__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8

meta::function('import', <<'__oK2Kj5RYHcEUK0Iyiqu8w7zipbg+QNF4VO4hm7BkUNA');
my ($name) = @_;
associate($name, join('', <STDIN>));
__oK2Kj5RYHcEUK0Iyiqu8w7zipbg+QNF4VO4hm7BkUNA

meta::function('load-dependencies', <<'__kReB7N+JwghuCBrba+IZ595SPDJVawc4OHcJ9OXp0Y4');
my $errors = '';
for (grep length, split /\n/, &{'dependencies'}()) {
  my $output = `$_ :check`;
  chomp $output;
  $errors .= $output ? "module $_\n$output\n" : '';
}

return terminal::message('error', "dependency loading failed:\n$errors") if $errors;
associate('code::cached-dependencies', join('', map `$_ :export`, grep length, split /\n/, &{'dependencies'}()));
terminal::message('loader', "imported dependencies");
__kReB7N+JwghuCBrba+IZ595SPDJVawc4OHcJ9OXp0Y4

meta::function('lock', <<'__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y

meta::function('ls', <<'__M3wGXSw8/xm3RiNq0uLWke1dHm2OWQbvJpHkngdPafg');
join("\n", sort keys %externalized_functions);
__M3wGXSw8/xm3RiNq0uLWke1dHm2OWQbvJpHkngdPafg

meta::function('ls-a', <<'__3Ou+kVmaLIe1oZKBOufKY7pSsksgTSAfNeXRniPFZPk');
join("\n", sort keys %data);
__3Ou+kVmaLIe1oZKBOufKY7pSsksgTSAfNeXRniPFZPk

meta::function('mv', <<'__ijyNZ8r34FVK0Ki9/Q0Irx5k9U0pZ+/frrdlu+qkEP4');
my ($from, $to) = @_;
messages::error("The '$from' attribute does not exist.") unless grep $from, keys %data;
associate($to, retrieve($from));
rm($from);
__ijyNZ8r34FVK0Ki9/Q0Irx5k9U0pZ+/frrdlu+qkEP4

meta::function('perl', <<'__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA');
my $result = eval($_[0]);
$@ ? $@ : $result;
__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA

meta::function('pop-state', <<'__eqnCLsMapvq2sYSx82KCxh25zmff+JIXFMYUan2kGKM');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__eqnCLsMapvq2sYSx82KCxh25zmff+JIXFMYUan2kGKM

meta::function('pull', <<'__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg

meta::function('push-state', <<'__ik0ofu7R8gHAKSmMjek79V+yfgdjdK5Jmtwf7h8SpJk');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__ik0ofu7R8gHAKSmMjek79V+yfgdjdK5Jmtwf7h8SpJk

meta::function('reload', <<'__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM');
execute($_) for (grep {! (/^internal::/ || /^bootstrap::/)} keys %data);
__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM

meta::function('repl', <<'__0gcQcyYhbrhjjhxxlOrXqdYD4Scmtqtwj2I3HF/c1Xo');
my ($name, @options) = @_;

use Term::ReadLine;

my $term = new Term::ReadLine "$0 repl for $name";
$term->ornaments(0);
my $OUT    = $term->OUT || \*STDOUT;
my $prompt = &{'api-name'}() . "/$name> ";

terminal::message('repl', 'initializing symbol table');
types::clear_symbols();
types::load_symbols($name) if $name;
types::initialize_symbols();
types::initialize_debugging_symbols() if grep /^debug$/, @options;

terminal::message('repl', 'running session');
run('cached-dependencies') unless grep /^nodeps$/, @options;
run($name) if $name;

terminal::message('repl', 'ready');
while (defined ($_ = $term->readline($prompt))) {
  my $result = eval {reader::read_form($_)->eval()->serialize()};
  $@ ? chomp $@ && terminal::message('error', $@) : terminal::message('result', $result);
}

print "\n";
if ($name) {
  terminal::message('repl', 'storing symbol table');
  types::store_symbols($name);
}

terminal::message('repl', 'exiting');
__0gcQcyYhbrhjjhxxlOrXqdYD4Scmtqtwj2I3HF/c1Xo

meta::function('rm', <<'__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww

meta::function('run', <<'__2RluS4s8uRjHD6Vtfi/a01P+Bo8jgpcLILqPCD4icpU');
shell::load_interactively(@_);
__2RluS4s8uRjHD6Vtfi/a01P+Bo8jgpcLILqPCD4icpU

meta::function('run-file', <<'__WceprRaNezbwObGfB9h6pwi0Ly281gdWz8CLtXL1ehY');
shell::initialize_symbol_table();
&{':main'}();
shell::load_from_file(@_);
__WceprRaNezbwObGfB9h6pwi0Ly281gdWz8CLtXL1ehY

meta::function('save', <<'__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw');
my $serialized_data = serialize();
my $final_state     = state();

my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

my $observed_state = `perl $temporary_filename state`;
chomp $observed_state;
if ($observed_state ne $final_state) {
  messages::error("The state of this object ($final_state) is inconsistent with the state of $temporary_filename ($observed_state).\n" .
                  "$0 has not been updated.");
} else {
  eval {file::write($0, $serialized_data)};
  warn $@ if $@;
  my $observed_self_state = `perl $0 state`;
  chomp $observed_self_state;
  unlink $temporary_filename if $observed_self_state eq $final_state;
}
__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw

meta::function('serialize', <<'__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw');
my @keys_without_internals = grep(!/^internal::/, sort keys %data);
join "\n", $data{'bootstrap::initialization'},
           (grep {$_} (map {serialize::single(@_)} grep(/^meta::/,  @keys_without_internals),
                                                   grep(!/^meta::/, @keys_without_internals),
                                                   grep(/^internal::/, sort keys %data))),
           "__END__";
__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw

meta::function('shell', <<'__y24Z0MyfVsS8IjvGqS/aSBwIs2L5yzllPmATpFIhCJg');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = &{'api-name'}() . '$ ';
my $OUT = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      my $result = eval {&{$function_name}(@args)};
      messages::warning($@) if $@;
      chomp $result;
      print $OUT $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  for my $watch (@{$transient{'watch_list'}}) {
    print $OUT eval($watch), "\n";
    print $OUT "Error evaluating watched expression $watch: $@\n" if $@;
  }

  $prompt = &{'api-name'}() . '$ ';
}
__y24Z0MyfVsS8IjvGqS/aSBwIs2L5yzllPmATpFIhCJg

meta::function('size', <<'__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80');
length(serialize());
__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80

meta::function('snapshot', <<'__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0

meta::function('state', <<'__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI');
sha256_base64 serialize();
__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI

meta::function('unlock', <<'__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA

meta::function('update-from', <<'__sbtFZ7CF4vK7UXLC1PKSByMYv06T9H7x38AkdJuxWm4');
# Upgrade all attributes that aren't customized. In this case, we want everything except for configuration::, code::, and attribute::.
return "That is a really bad idea." if $0 =~ /\.\/(.*)/ && $_[0] eq $1 || $_[0] eq $0;

&{'push-state'}();
print "Updating... Please be patient as this is an unjustifiably slow process.\n";
for my $attribute (grep length && ! (/^configuration::/ || /^code::/ || /^attribute::/ || /^function::pop-state$/ ||
                                     /^list::/ || /^issue::/ || /^data::/), split(/\n/, `$_[0] ls-a`)) {
  associate($attribute, join('', `$_[0] cat $attribute`));
  print '.';
}

print "\nReloading new attributes\n";
reload();
"Imported from $_[0]. Run pop-state to undo this change.\n(The value of pop-state wasn't changed during the update.)";
__sbtFZ7CF4vK7UXLC1PKSByMYv06T9H7x38AkdJuxWm4

meta::function('usage', <<'__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I');
<<"EOD" . join '  ', split /\n/, ls ();
Usage: $0 [options] action [arguments]
Defined actions:
EOD
__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I

meta::function('vim', <<'__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for map {s/^vim_highlighter:://o; $_} grep /^vim_highlighter::/, sort keys %data;
__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec

meta::internal_function('associate', <<'__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless grep {$_ eq $namespace} @data_types;
$data{$name} = $value;
execute($name) if $options{'execute'};
__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0

meta::internal_function('basename', <<'__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw

meta::internal_function('complete', <<'__lhlD80z2kvEUEeHPqLFw6JE8xUdXr6J5Q1gXHg4beHg');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__lhlD80z2kvEUEeHPqLFw6JE8xUdXr6J5Q1gXHg4beHg

meta::internal_function('execute', <<'__Ge94WTpmLuqsMDappj5G/G2BKILAE0GjeCqAeHLW6fQ');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__Ge94WTpmLuqsMDappj5G/G2BKILAE0GjeCqAeHLW6fQ

meta::internal_function('file::read', <<'__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg

meta::internal_function('file::write', <<'__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o

meta::internal_function('invoke_editor_on', <<'__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U');
my ($data, %options) = @_;
my $content_hash     = sha256_base64($data);
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my (undef, $filename) = tempfile("$0." . ("X" x 32), OPEN => 0);
$filename .= $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U

meta::internal_function('messages::error', <<'__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4');
my ($message) = @_;
die "$message\n";
__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4

meta::internal_function('messages::warning', <<'__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc');
my ($message) = @_;
print "$message\n";
__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc

meta::internal_function('namespace', <<'__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug

meta::internal_function('retrieve', <<'__Erqqkp11FEHKsitr0DEJZ6OCGDYAs+U6BSu4UvLvsFM');
@data{@_};
__Erqqkp11FEHKsitr0DEJZ6OCGDYAs+U6BSu4UvLvsFM

meta::internal_function('serialize::single', <<'__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = "__" . sha256_base64 $contents;
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE

meta::internal_function('state_based_filename', <<'__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw

meta::issue('bugs', <<'__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU');

__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU

meta::issue('test-cases', <<'__KtdLV8oE00qsOR/lprnhBJF7moFLLNHXYD+k6Ih9sDs');
Static importing
__KtdLV8oE00qsOR/lprnhBJF7moFLLNHXYD+k6Ih9sDs

meta::issue('todos', <<'__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU');

__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU

meta::library('datatypes', <<'__iVQ3SjWisZ6HSjTvm8DnyJi4cvNtxTVPHV0eH/2rhro');
# Data type definitions for the interpreter.

package types;

my %symbol_table;

sub clear_symbols {%symbol_table = ()}
sub store_symbols {my %h = %symbol_table; $transient{$_[0]} = \%h}
sub load_symbols  {%symbol_table = %{$transient{$_[0]}} if ref $transient{$_[0]} eq 'HASH'}

sub initialize_debugging_symbols {
  symbol('counter')->bind(counter(0));
  symbol('trace')->bind(lambda('[trace]', sub {
    my $value = $_[0]->eval();
    terminal::message('trace', $_[0]->serialize());
    $value;
  }));
}

sub initialize_symbols {
  symbol('gensym')->bind(lambda('[gensym]', \&gensym));
  symbol('placeholder')->bind(lambda('[placeholder]', sub {placeholder($_[0]->eval())}));

  symbol('beta')->bind(lambda('[beta]', sub {
    my $symbol = $_[0];
    die 'Cannot create beta-expander for non-symbol value ' . $symbol->serialize() unless ref $symbol eq 'symbol';
    lambda("[beta $$symbol -> ...]", sub {
      expander($symbol, $_[0]);
    });
  }));

  symbol('cons')->bind(lambda('[cons]', sub {
    my $head = $_[0]->eval();
    lambda(sub {'(cons ' . $head->serialize() . ' ...)'}, sub {
      cons($head, $_[0]->eval());
    });
  }));

  symbol('o\'')->bind(lambda('[o\']', sub {
    my $f = $_[0]->eval();
    lambda(sub {'[' . $f->serialize() . ' o\' ...]'}, sub {
      composition($f, $_[0]->eval());
    });
  }));

  symbol(':')->bind(nil());

  symbol('serialize')->bind(lambda('[serialize]', sub {symbol($_[0]->eval()->serialize())}));

  symbol('perl')->bind(lambda('[perl]', sub {
    eval $_[0]->serialize();
  }));
}

sub trace {
  my ($f, $name) = @_;
  sub {
    my $result = eval {$f->(@_)};
    terminal::message($name, $_[0]->serialize() . ($_[1] ? ' invoked on ' . $_[1]->serialize() : '')) and die $@ if $@;
    $result;
  }
}

sub deftype {
  my ($name, %members) = @_;
  *{"types::$name"} = sub {bless $members{'new'}->(@_), $name};
  *{"${name}::$_"} = $members{$_} for keys %members;

  # Treat eval and call specially. We want to make sure that we have a backtrace of values at the very least.
  *{"${name}::$_"} = trace($members{$_}, $_) for qw/eval call/;
}

our $id = sub {$_[0]};

sub method {
  my %table = @_;
  sub {
    my $self = $_[0];
    my $lambda_wrap = sub {my $name = $_[0]; lambda(sub {'(' . $self->serialize() . ' ' . $name . ')'}, $_[1])};
    if (ref $_[1] eq 'symbol' && $table{${$_[1]}}) {
      # Default behavior -- return the value directly, wrapping it in a serializable lambda
      # closure only if it's a function.
      my $v = $table{${$_[1]}}->($self, $value);
      return $lambda_wrap->(${$_[1]}, $v) if ref $v eq 'CODE';
      return $v;
    } else {
      $table{''} ? $table{''}->($self, $_[1]) :
                   die 'Cannot apply ' . $self->serialize() . ' to ' . $_[1]->serialize();
    }
  };
}

deftype 'composition', new       => sub {[@_]},
                       eval      => $id,
                       call      => sub {$_[0][0]->call($_[0][1]->call($_[1]))},
                       serialize => sub {'[' . $_[0][0]->serialize() . ' o\' ' . $_[0][1]->serialize() . ']'};

deftype 'lambda', new       => sub {[@_]},
                  eval      => $id,
                  call      => sub {$_[0][1]->($_[1])},
                  serialize => sub {ref $_[0][0] eq 'CODE' ? $_[0][0]->() : $_[0][0]};

our $true  = lambda(sub {'true'},  sub {my $x = $_[0]; lambda(sub {'(true ' . $x->serialize() . ')'}, sub {$x->eval()})});
our $false = lambda(sub {'false'}, sub {lambda(sub {'(false ' . $_[0]->serialize() . ')'}, sub {$_[0]->eval()})});

deftype 'symbol',
  new       => sub {\$_[0]},
  eval      => sub {$symbol_table{${$_[0]}} ||
                    die 'Cannot evaluate symbol ' . $_[0]->serialize() . ' because it is undefined.'},

  bind      => sub {$symbol_table{${$_[0]}} = $_[1]; $_[0]},
  unbind    => sub {delete $symbol_table{${$_[0]}}; $_[0]},
  equals    => sub {ref $_[1] eq 'symbol' ? ${$_[0]} eq ${$_[1]} : ${$_[0]} eq $_[1]},
  call      => method(bind     => sub {my $self = $_[0]; sub {$self->bind($_[0]->eval())}},
                      'bound?' => sub {$symbol_table{${$_[0]}} ? $true : $false},
                      unbind   => sub {my $self = $_[0]; sub {$self->unbind(); $_[0]->eval()}},
                      value    => sub {$_[0]->eval()},
                      '<='     => sub {my $self = $_[0]; sub {$$self le ${$_[0]->eval()} ? $true : $false}},
                      '+'      => sub {my $self = $_[0]; sub {symbol($$self . ${$_[0]->eval()})}},
                      split    => sub {cons_from_array(map {symbol($_)} split //, ${$_[0]})},
                      ''       => sub {$_[1]->eval()->call($_[0])}),
  serialize => sub {${$_[0]}};

my $gensym_count = 0;
sub gensym {
  my $value = $_[0]->eval();
  die 'Cannot call gensym on non-symbol value: ' . $value->serialize() unless ref $value eq 'symbol';
  ++$gensym_count;
  symbol("#$$value$gensym_count");
}

deftype 'placeholder',
  new       => sub {\$_[0]},
  eval      => sub {${$_[0]}},
  call      => sub {$_[0]->eval()->call($_[1])},
  serialize => sub {'[' . ${$_[0]}->serialize() . ']'};

sub lazy_rewrite {
  sub merge_by_composition {
    my ($h1, $h2) = @_;
    return $h1 unless $h2;
    return $h2 unless $h1;
    return $h1 if $h1 eq $h2;

    my %hash = ();
    $hash{$_} = ref ${$h1}{$_} eq 'symbol' && ${$h2}{${${$h1}{$_}}} || ${$h1}{$_} for keys %$h1;
    $hash{$_} = $hash{$_} || ${$h2}{$_}                                           for keys %$h2;
    \%hash;
  }

  my ($form, $table) = @_;
  return $form unless $table;
  return ${$table}{${$form}} || $form if ref $form eq 'symbol';

  if (ref $form eq 'cons') {
    return cons(${$form}[0], ${$form}[1], merge_by_composition(${$form}[2], $table)) if ${$form}[2];
    return cons(${$form}[0], ${$form}[1], $table);
  }

  return $form;
}

deftype 'expander', new       => sub {[@_]},
                    eval      => $id,
                    head      => sub {$_[0][0]},
                    tail      => sub {$_[0][1]},
                    call      => sub {lazy_rewrite($_[0]->tail(), {$_[0]->head()->serialize() => $_[1]})},
                    serialize => sub {'[' . $_[0]->head()->serialize() . ' -> ' . $_[0]->tail()->serialize() . ']'};

deftype 'counter', new       => sub {\$_[0]},
                   eval      => sub {counter(${$_[0]} + 1)},
                   call      => sub {die 'Cannot call ' . $_[0]->serialize() . ' on ' . $_[1]->serialize()},
                   serialize => sub {"[counter +${$_[0]}]"};

deftype 'cons', new       => sub {\@_},
                eval      => sub {$_[0]->head()->eval()->call($_[0]->tail())},
                head      => sub {lazy_rewrite($_[0][0], $_[0][2])},
                tail      => sub {lazy_rewrite($_[0][1], $_[0][2])},
                call      => method(head => sub {$_[0]->head()},
                                    tail => sub {$_[0]->tail()},
                                    call => sub {my $self = $_[0]; sub {$_[0]->eval()->call($self->head())->call($self->tail())}},
                                    '<=' => sub {my $self = $_[0]; sub {$self eq $_[0]->eval() ? $true : $false}},
                                    ''   => sub {$_[1]->eval()->call($_[0])}),
                serialize => sub {'(' . $_[0]->head()->serialize() . ' . ' . $_[0]->tail()->serialize() . ')'};

sub cons_from_array {
  return nil() unless @_;
  my $tail = pop @_;
  return cons(cons_from_array(@_), $tail);
}

my $nil = '';
deftype 'nil', new       => sub {\$nil},
               eval      => $id,
               call      => sub {$_[1]->eval()},
               serialize => sub {':'};

sub number_op(&) {
  my $implementation = $_[0];
  sub {my $self = $_[0]; sub {number($implementation->($$self, ${$_[0]->eval()}))}}
}

deftype 'number', new       => sub {\$_[0]},
                  eval      => $id,
                  call      => method('<=' => sub {my $self = $_[0]; sub {$$self <= ${$_[0]->eval()} ? $true : $false}},
                                      '$'  => sub {symbol(chr ${$_[0]})},
                                      '+'  => number_op {$_[0]  + $_[1]},
                                      '-'  => number_op {$_[0]  - $_[1]},
                                      '*'  => number_op {$_[0]  * $_[1]},
                                      '/'  => number_op {$_[0]  / $_[1]},
                                      '%'  => number_op {$_[0]  % $_[1]},
                                      '&'  => number_op {$_[0]  & $_[1]},
                                      '|'  => number_op {$_[0]  | $_[1]},
                                      '^'  => number_op {$_[0]  ^ $_[1]},
                                      '<<' => number_op {$_[0] << $_[1]},
                                      '>>' => number_op {$_[0] >> $_[1]},
                                      ''   => sub {return number(${$_[0]} * ${$_[1]}) if ref $_[1] eq 'number';
                                                   return $_[1]->eval()->call($_[0])}),
                  serialize => sub {${$_[0]}};
__iVQ3SjWisZ6HSjTvm8DnyJi4cvNtxTVPHV0eH/2rhro

meta::library('reader', <<'__FNIGiO/4HpdvKl1LG4oDoOJ1jQgaaKgwGIBLzZKw+uo');
package reader;

sub read_form {
  sub lex {
    grep length, split /([()])|\s+|("(?:[^"\\]|\\.)*")/so, $_[0];
  }

  sub unquote {
    map {if (s/^"(.*)"$/\1/so) {
           s/\\n/\n/go;
           s/\\r/\r/go;
           s/\\(.)/\1/sgo;
         }
         $_} @_;
  }

  sub parse {
    my ($value, $xs) = @_;
    my $x = shift @$xs;

    return $value                                                    if $x eq ')' || $x eq '';
    return parse(types::cons($value, parse(types::nil(), $xs)), $xs) if $x eq '(';
    return parse(types::cons($value, types::number($x)), $xs)        if $x =~ /^-?[\d.]+$/o;
    return parse(types::cons($value, types::symbol(unquote $x)), $xs);
  }

  parse types::nil(), [lex $_[0]];
}

sub read_paragraph {
  sub flatten_cons_tree {
    return () if ref $_[0] eq 'nil';
    return (flatten_cons_tree($_[0]->head()), $_[0]->tail());
  }

  return () if $_[0] =~ /^\s*[^( ]/o;
  return flatten_cons_tree(read_form $_[0]);
}

sub read_document {
  map {read_paragraph $_} split /\n(?:\s*\n)+/o, $_[0];
}
__FNIGiO/4HpdvKl1LG4oDoOJ1jQgaaKgwGIBLzZKw+uo

meta::library('shell', <<'__sbRiGMNXhqgt65vHRHrGFknAxvnRwNlctXwzHgwFybo');
package shell;

sub definitions           {map reader::read_document(::retrieve("code::$_")), @_}
sub definitions_from_file {map reader::read_document(file::read($_)), @_}

sub initialize_symbol_table {
  types::clear_symbols;
  types::initialize_symbols;
  types::initialize_debugging_symbols;
}

sub make_loader {
  my ($loader) = @_;
  sub {
    for my $document (@_) {
      terminal::message('shell', "loading $document");
      for ($loader->($document)) {
        my $result = eval {$_->eval()};
        chomp $@ and terminal::message('error', "$@ in " . $_->serialize()) if $@;
        terminal::message('loader', $result->serialize()) unless $@;
      }
    }
  };
}

*{'load_interactively'} = make_loader(\&definitions);
*{'load_from_file'}     = make_loader(\&definitions_from_file);

sub load_quietly {map $_->eval()->serialize(), definitions @_}
__sbRiGMNXhqgt65vHRHrGFknAxvnRwNlctXwzHgwFybo

meta::library('terminal', <<'__UqcWaKvw20yAGxzo+r5ZwEssO3nQjhzUp8hYS5n6iIs');
# Functions for nice-looking terminal output.

package terminal;

use constant black  => "0;0";
use constant red    => "1;31";
use constant yellow => "1;33";
use constant green  => "1;32";
use constant blue   => "1;34";
use constant purple => "1;35";
use constant cyan   => "1;36";

my %default_colors = (repl    => green, result  => blue,   error   => red,
                      fail    => red,   warning => yellow, loader  => green,
                      shell   => blue,  trace   => cyan,   eval    => yellow,
                      call    => yellow);

my $longest_prefix = 0;
$longest_prefix = $longest_prefix < $_ ? $_ : $longest_prefix for map length, keys %default_colors;

sub message {
  my ($prefix, $message) = @_;
  my $color = $default_colors{$prefix};
  my $padding = ' ' x ($longest_prefix - length $prefix);
  print "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__UqcWaKvw20yAGxzo+r5ZwEssO3nQjhzUp8hYS5n6iIs

meta::list('dependencies', <<'__B9LozXyj4sAOqItRCM44CqOIDe3JaFJ07LQ+N9F06qs');

core
hash
__B9LozXyj4sAOqItRCM44CqOIDe3JaFJ07LQ+N9F06qs

meta::vim_highlighter('gnarly', <<'__moNoxv/wRgmxYv1hQzACzqd9mu+BTF1vW1lk51p3gQ4');
" Gnarly
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   A minimalistic combinatory language with rewriting

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

set iskeyword=33-39,42-126,128-255

syn keyword gnarlyDangerous        perl defperl !!< !!> contained
syn keyword gnarlyBuiltins         o' beta placeholder contained
syn keyword gnarlyMethods          bind unbind value head tail contained
syn keyword gnarlyFunctions        gensym counter trace type cons fail serialize : contained
syn keyword gnarlyUserFunctions    ' '' :: o tr fn :< :> :<' :>' ::< ::> # '< '> '>' let en qn def fail$ assert contained
syn keyword gnarlyBooleans         k k' k: k:' contained
syn match   gnarlyNumbers          /\<-\?[0-9.]\+\>/ contained
syn match   gnarlyParens           /[()]/ contained

syn region  gnarlyQuoted           start=/"/ end=/"/ skip=/\\.\|\n/ contained

syn keyword gnarlyBooleanFunctions <= == < > >= != && \|\| ! r== contained
syn keyword gnarlyListFunctions    * / % ++ :? reverse reverse' list cons' $ $'> $* contained
syn keyword gnarlyConditionals     cond contained

syn cluster gnarlySyntax add=gnarlyBuiltins,gnarlyMethods,gnarlyFunctions,gnarlyUserFunctions,gnarlyNumbers,gnarlyParens,gnarlyBooleans
syn cluster gnarlySyntax add=gnarlyBooleanFunctions,gnarlyListFunctions,gnarlyConditionals,gnarlyQuoted,gnarlyDangerous

syn region  gnarlyCodeRegion    start=/^\s*(/     end=/^$/ contains=@gnarlySyntax transparent fold
syn region  gnarlyCommentRegion start=/^\s*[^( ]/ end=/^$/ fold

hi link gnarlyBooleans         Boolean
hi link gnarlyBooleanFunctions Operator
hi link gnarlyListFunctions    Operator
hi link gnarlyCommentRegion    Comment
hi link gnarlyBuiltins         Keyword
hi link gnarlyFunctions        Keyword
hi link gnarlyConditionals     Keyword
hi link gnarlyMethods          Keyword
hi link gnarlyUserFunctions    Keyword
hi link gnarlyNumbers          Number
hi link gnarlyParens           Special
hi link gnarlyQuoted           String

hi link gnarlyDangerous        Special

set foldmethod=syntax

let b:current_syntax = "gnarly"
__moNoxv/wRgmxYv1hQzACzqd9mu+BTF1vW1lk51p3gQ4

meta::internal('runtime', <<'__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ');
my $initial_state = sha256_base64 serialize();

push @script_args, shift @ARGV while @ARGV && $ARGV[0] =~ /^-/;

my $default_action = retrieve('data::default-action');
chomp $default_action;
my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};
my $result = &{$function_name}(@ARGV);
chomp $result;
print "$result\n" if $result;

END {
  my $serialized_data = serialize();
  my $final_state     = sha256_base64 $serialized_data;
  save() unless $initial_state eq $final_state;
}

__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ

__END__