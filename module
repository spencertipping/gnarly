#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

meta::meta('datatypes::attribute', <<'__PYmyPgg2sMijXksysuPrJU0k2SAh5zzFu2hvd7hDcoU');
meta::define_form 'attribute', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "attribute::$name";
  *{$name} = sub {
    associate("attribute::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    retrieve("attribute::$name");
  };
};
__PYmyPgg2sMijXksysuPrJU0k2SAh5zzFu2hvd7hDcoU

meta::meta('datatypes::bootstrap', <<'__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM');
meta::define_form 'bootstrap', sub {};
__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM

meta::meta('datatypes::code', <<'__OEWZ93LGHT8yOiO/06UyIrAiKTXnAbI7tYl7+93uAT0');
meta::define_form 'code', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "code::$name";
  *{$name} = sub {
    edit("code::$name");
  };
};
__OEWZ93LGHT8yOiO/06UyIrAiKTXnAbI7tYl7+93uAT0

meta::meta('datatypes::configuration', <<'__my6exSOOfpxIJLIUfmSVVMUaquAgbayoNBj9guBwbYU');
meta::define_form 'configuration', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "configuration::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__my6exSOOfpxIJLIUfmSVVMUaquAgbayoNBj9guBwbYU

meta::meta('datatypes::data', <<'__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U');
meta::define_form 'data', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "data::$name";
  *{$name} = sub {
    associate("data::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    retrieve("data::$name");
  };
};
__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U

meta::meta('datatypes::function', <<'__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0');
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "function::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0

meta::meta('datatypes::internal_function', <<'__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong');
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong

meta::meta('datatypes::library', <<'__3RHc2q2OKjeHL1QRq6jhHHCeSrNLDPWTwSax7MclXRE');
meta::define_form 'library', sub {
  eval $_[1];
  warn $@ if $@;
};
__3RHc2q2OKjeHL1QRq6jhHHCeSrNLDPWTwSax7MclXRE

meta::meta('datatypes::list-type', <<'__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w');
meta::define_form '_list_type', sub {
  my ($outer_name, $outer_value) = @_;
  $externalized_functions{$outer_name} = "_list_type::$outer_name";
  
  *{$outer_name} = sub {
    associate("${outer_value}::$_", '') for @_;
  };

  meta::define_form $outer_value, sub {
    my ($name, $value) = @_;
    $externalized_functions{$name} = "${outer_value}::$name";
    *{$name} = sub {
      my ($command, @xs) = @_;
      my $xs = join "\n", @xs;
      return grep length, split /\n/, retrieve("${outer_value}::$name")               if $command eq 'items';
      associate("${outer_value}::$name", retrieve("${outer_value}::$name") . "\n$xs") if $command eq 'add' || $command eq '<<';
      edit("${outer_value}::$name")                                                   if $command eq 'edit';
      return retrieve("${outer_value}::$name");
    };
  };
};
__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w

meta::meta('datatypes::vim-highlighter', <<'__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0');
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0

meta::meta('internal::runtime', <<'__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA');
meta::define_form 'internal', \&meta::meta::implementation;
__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA

meta::_list_type('issue', <<'__SlAoRtBw4giLcCWr6AYpgwvwPXq1Yk1ekfMyvJ0EnT8');
issue
__SlAoRtBw4giLcCWr6AYpgwvwPXq1Yk1ekfMyvJ0EnT8

meta::_list_type('list', <<'__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk');
list
__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk

meta::attribute('module-api-version', <<'__0P9ZdLaqUs9WK+pZIYQMAyqGCpGjUS9/6Pdo9rvgBfY');
1.0
__0P9ZdLaqUs9WK+pZIYQMAyqGCpGjUS9/6Pdo9rvgBfY

meta::attribute('module-name', <<'__bhmtqnYh71vFMr2U62YpxfaBvNsPBiSBNLH5p4LuAuo');
new-module
__bhmtqnYh71vFMr2U62YpxfaBvNsPBiSBNLH5p4LuAuo

meta::attribute('module-revision', <<'__X+zrZv/IbzjZUnhsbWlsecLbwjndTpG0ZynXOif7V+k');
0
__X+zrZv/IbzjZUnhsbWlsecLbwjndTpG0ZynXOif7V+k

meta::bootstrap('initialization', <<'__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc');
#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc

meta::code('dependencies', <<'__H5CDOI7uffSvT4dm4LbThmGy2M/0RvwfteMq4JHjRT0');
This is generated automatically by import-dependencies. You shouldn't put any changes you care about in here.
__H5CDOI7uffSvT4dm4LbThmGy2M/0RvwfteMq4JHjRT0

meta::code('integration-tests', <<'__Q4ZqcS3Gx3zaAHh8IKp8z9BT+IJxx4qAJ/5ZT2Y8kDU');
Integration tests. These are run after your code is loaded and the unit tests have been run.
__Q4ZqcS3Gx3zaAHh8IKp8z9BT+IJxx4qAJ/5ZT2Y8kDU

meta::code('source', <<'__VL6xU98RMGHqD4HbYlgoMZhC5tG3zHObILkqI5aa6r4');
Gnarly Standard Library | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license.

Quoting.
Applying the identity beta expander consumes an evaluation step but does not carry it forward. Thus it can be useful for absorbing an evaluation as quoting
is commonly used to do. In particular, it can delay evaluation for parameters passed to functions; for instance, (o my-function ' stuff), or, more
concisely, ('> my-function stuff) will treat the /stuff/ as being quoted, just as if (my-function (' stuff)) had been typed. The double-quote operator, '',
is used in conjunction with o'. o' is the system composition function, which does not protect the results of the first function from the effects of the
second function's argument evaluation.  Also in (' ::> bind (:< (beta _ (o' _ ::)))) the mix is the :: operator, which double-evaluates an expression. This
is equivalent to Common Lisp's /eval/ function, which evaluates its argument implicitly (since it is not a macro), and then evaluates it again.

  (beta _ _ '  bind (beta _ _))
  (' ''        bind (beta _ (' _)))
  (' ::        bind (o' : :))

Composition.
These let you easily put evals or quotes onto existing functions.

  (' :<  bind (o'  :))
  (' ::< bind (o' ::))
  (' '<  bind (o'  '))
  (' :>  bind (:< (beta _ (o' _  :))))
  (' ::> bind (:< (beta _ (o' _ ::))))
  (' '>  bind (:< (beta _ (o' _ ''))))

Inline comments.
This is used inside other expressions when you want to write a note; the idea is that it returns itself so that you can write whatever symbols you want,
including function names and properly-formed lists. For example, to comment a function:
|
| (def foo (fn x (k' (# This function does x. (Not to say it doesn't do other things as well.))
|                    (stuff))))
|
Notice that we use k' to remove the comment's value. If we didn't, then the comment would eat up the whole rest of the function.

  (' # bind (:< (beta _ #)))

Normal composition.
This doesn't double-evaluate stuff when there are two functions. This is by virtue of the fact that we quote the result of the first function. If the second
function doesn't evaluate, then it will just get a quoted value; however, it makes no sense to place a non-evaluating function on the left-hand side of a
composition.

  (' o bind (:< (beta _ (o' (o' _ ')))))

Functions and macros.
Definitions for creating functions and macros.

  tr = translate code. This is an unevaluative macro that essentially does beta-substitution and evaluates its output.
  fn = function. This behaves like lambda in most languages, except that you can compose the quote function (or any other beta) onto it to make it not evaluate
       its parameter.
  en = evaluative function. It evaluates the things you pass in as the /name/ and /expansion/.
  qn = quoted function. Just like function, except that its parameter is not evaluated.

  (' tr  bind (:< (::> (beta ev (:< (beta name (:< (beta ev (:< (beta name ev)))))))) (' (gensym (' γ)))))
  (' fn  bind (::> (tr ev (tr name (tr ev (o' (:< (beta name ev)) placeholder))))     (' (gensym (' λ)))))

  (' en  bind     (fn name     (fn expansion (:> (:> fn name) expansion))))
  (' qn  bind ('> (fn name ('> (fn expansion ('> (en name expansion)))))))

Shorthands.
let and def are two shorthands for common operations. let is used to define a local variable, like this:
|
| (let x 5 (x + 1))
|
and def is used to define an entry in the global symbol table, like this:
|
| (def foo (' bar))
|
Note that there aren't really any local variables -- they are all constants and get rewritten to placeholder expressions during function application.

  (' let bind (qn name (fn value (qn expansion ((en name expansion) value)))))
  (' def bind (qn name (name bind)))

  (def _ (fn _))

Booleans and relational operators.
Booleans are Church-encoded, and logical operators try to get the result as much evaluated as possible to maximize performance. The meanings of these functions
correspond to their names, with the first four ultimately rooted in the SK combinator calculus. K is a function that returns a constant-returning function; that
is, k x y = x. k' returns y; that is, it absorbs its parameter. Normally, k and k' are lazy in that they fail to evaluate their unused parameter. However,
sometimes it is necessary to evaluate both, so k: and k:' are provided for this purpose.

Relational operators operate on partially or fully ordered things. The only assumption that is made is that the things implement <=, the less-than-or-equal-to
operator. Deriving the other operators is trivial given this one, and it also provides an indication of whether something is not comparable to something else
(in this case, x <= y and y <= x are both false).

  (def k   (fn x (qn y x)))
  (def k'  (qn x (fn y y)))
  (def k:  (fn x (fn y x)))
  (def k:' (fn x (fn y y)))

  (def && (fn b1 (fn b2 (b1 (b2 k k') k'))))
  (def || (fn b1 (fn b2 (b1 k (b2 k k')))))
  (def !  (fn b (b k' k)))

  (def == (fn x (fn y (&& (x <= y) (y <= x)))))
  (def <  (fn x (fn y (&& (x <= y) (! (y <= x))))))
  (def >  (fn x (fn y (&& (y <= x) (! (x <= y))))))
  (def >= (fn x (fn y (y <= x))))
  (def != (fn x (fn y (! (x == y)))))

Lists.

  (def :? (fn xs (== (type xs) (' nil))))

  (def *  (fn f  (fn xs (:? xs : (cons (* f (xs head)) (f (xs tail)))))))
  (def %  (fn f  (fn xs (:? xs : (f (xs tail) (cons (% f (xs head)) (xs tail)) (% f (xs head)))))))
  (def /  (fn f  (fn xs (:? (xs head) (xs tail) (f (/ f (xs head)) (xs tail))))))
  (def ++ (fn xs (fn ys (:? ys xs (cons (++ xs (ys head)) (ys tail))))))

  (def reverse' (fn xs (fn ys (:? ys xs (reverse' (cons xs (ys tail)) (ys head))))))
  (def reverse  (reverse' :))

Cond.
This is cool. It behaves just like the Lisp cond form, so that you have a list of 2-tuples of conditions and values and the first true conditional has its value
returned. The internal workings below can be read as the following in English: "evaluate the tail of the first expression whose tail of whose head is true."

  (def cond (qn options (:: (* (_ (_ tail)) (% (_ (:: (_ head tail))) (reverse options)) tail)))

Numbers.

  (def range (fn lower (fn upper (lower <= upper (cons (range lower (upper - 1)) upper) :)))))

  (def times  (fn n (fn f (n <= 0 f (let _ (f n) (times (n - 1) f))))))
  (def times_ (fn n (o (times n) _)))

State.

  (def y (qn name (qn v (let s' (gensym (' y))
                        (s' bind ((en name v) s') value)))))

  (def state (fn iv (let s (gensym (' state))
                    (y self (qn method (cond (((== method (' >>))     (s value))
                                              ((== method (' <<))     (fn v (k:' (s bind v) (self value))))
                                              ((== method (' symbol)) s)
                                              ((== method (' unbind)) (o (s unbind) (self unbind))))))))))
__VL6xU98RMGHqD4HbYlgoMZhC5tG3zHObILkqI5aa6r4

meta::code('tests', <<'__m6+oJxwoZaK1TMUfaV+FgxyaXqlCLt6Lb4BRNC4oCpw');
Unit tests for this module. Integration tests should go into code::integration-tests.
__m6+oJxwoZaK1TMUfaV+FgxyaXqlCLt6Lb4BRNC4oCpw

meta::data('default-action', <<'__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc');
shell
__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc

meta::data('meta-associations', <<'__kVffjc6irPQVBintvaQyaR90XJ4gIZIYiWKMIFPuioA');
^function:: .pl
^library:: .pl
^internal_function:: .pl
^meta:: .pl
^bootstrap:: .pl
^code:: .gnarly
^vim_highlighter:: .vim
__kVffjc6irPQVBintvaQyaR90XJ4gIZIYiWKMIFPuioA

meta::function('add-to', <<'__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q');
my ($filename) = @_;
my @members = grep /^implementation::/, keys %data;

for (@members) {
  my $destination_name = basename($_);
  open my($handle), "| $filename import $destination_name" or messages::error("Attribute $_ could not be written.");
  print $handle retrieve($_);
  close $handle;
}
__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q

meta::function('api-name', <<'__qA8PQrovsL6EIw5iatzFboQXAdvl064VoxzO6b8D3oQ');
&{'module-name'}() . ':' . &{'module-api-version'}();
__qA8PQrovsL6EIw5iatzFboQXAdvl064VoxzO6b8D3oQ

meta::function('attributes', <<'__SHSGXpl5WufcHc7hGxs0XPxlKSgo0XQ752HpjI4rgRg');
grep /^attribute::/, sort keys %data;
__SHSGXpl5WufcHc7hGxs0XPxlKSgo0XQ752HpjI4rgRg

meta::function('cat', <<'__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk');
my ($name) = @_;
$data{$name};
__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk

meta::function('clone', <<'__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY

meta::function('cp', <<'__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4

meta::function('create', <<'__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc');
my ($name, $value) = @_;
messages::error("Attribute $name already exists.") if grep {$_ eq $name} keys %data;
if ($value) {
  associate($name, $value);
} else {
  associate($name,'');
  edit ($name);
}
__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc

meta::function('edit', <<'__wmkQAgPhtPrNx2Sc88M1MNK4gG2sn/UGqsnAtRv6ksY');
my ($name, %options) = @_;

my $meta_extension = join '', grep {
  my $s = $_;
  $s =~ s/\s.*$//;
  $name =~ /$s/
} split /\n/, &{'meta-associations'}();

$meta_extension =~ s/^.*\s//;
chomp $meta_extension;

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $meta_extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
save();
__wmkQAgPhtPrNx2Sc88M1MNK4gG2sn/UGqsnAtRv6ksY

meta::function('exists', <<'__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk');
my $name = shift;
grep {$_ eq $name} keys %data;
__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk

meta::function('full-name', <<'__X5DqVkiY6nnaoUwhy1rWlslSD2vlNZ5zkbCZRfb1ITI');
&{'api-name'}() . ':' . &{'module-revision'}();
__X5DqVkiY6nnaoUwhy1rWlslSD2vlNZ5zkbCZRfb1ITI

meta::function('grab', <<'__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8');
my ($filename, @attribute_names) = @_;
associate("implementation::$_", `$filename cat $_`) for @attribute_names;
__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8

meta::function('import', <<'__oK2Kj5RYHcEUK0Iyiqu8w7zipbg+QNF4VO4hm7BkUNA');
my ($name) = @_;
associate($name, join('', <STDIN>));
__oK2Kj5RYHcEUK0Iyiqu8w7zipbg+QNF4VO4hm7BkUNA

meta::function('lock', <<'__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y

meta::function('ls', <<'__M3wGXSw8/xm3RiNq0uLWke1dHm2OWQbvJpHkngdPafg');
join("\n", sort keys %externalized_functions);
__M3wGXSw8/xm3RiNq0uLWke1dHm2OWQbvJpHkngdPafg

meta::function('ls-a', <<'__6jKXRDXpIkzIOkcLtB2FOSTuZxqjBLyLZsF1vEmVn18');
join("\n", map {"  $_"} sort keys %data) . "\n";
__6jKXRDXpIkzIOkcLtB2FOSTuZxqjBLyLZsF1vEmVn18

meta::function('mv', <<'__PY7iwIY+6QtPN4V5hV4MOImRJVAKDkMmEKtkN34cv5Y');
my ($from, $to) = @_;
messages::error("The '$from' attribute does not exist.") unless grep $from, keys %data;
$data{$to} = $data{$from};
delete $data{$from};
__PY7iwIY+6QtPN4V5hV4MOImRJVAKDkMmEKtkN34cv5Y

meta::function('perl', <<'__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA');
my $result = eval($_[0]);
$@ ? $@ : $result;
__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA

meta::function('pull', <<'__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg

meta::function('reload', <<'__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM');
execute($_) for (grep {! (/^internal::/ || /^bootstrap::/)} keys %data);
__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM

meta::function('repl', <<'__eaOjbH1kQd3440ehk7CM62fmFCema5/utZmbcL1XhjA');
my ($name) = @_;

print "This session will not be stored.\nTo create or load a stored session, run repl <name>.\n" unless $name;

use Term::ReadLine;

my $term = new Term::ReadLine "$0 repl for $name";
$term->ornaments(0);
my $OUT = $term->OUT || \*STDOUT;

my $prompt = &{'api-name'}() . " repl/$name> ";

run($name);

while (defined ($_ = $term->readline($prompt))) {
  my $result = eval {reader::read_form($_)->eval()->serialize()};
  print $OUT $@ ? "[\033[1;31merror\033[0;0m]: $@" : "[\033[1;34mresult\033[0;0m]: $result\n";
}
__eaOjbH1kQd3440ehk7CM62fmFCema5/utZmbcL1XhjA

meta::function('rm', <<'__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww

meta::function('run', <<'__FMEGtHmllv/VCSDqZoJ72pSAMmn4rqikSbBLvsu8RuM');
join "\n", map $_->eval()->serialize(), map reader::read_document(retrieve("code::$_")), @_;
__FMEGtHmllv/VCSDqZoJ72pSAMmn4rqikSbBLvsu8RuM

meta::function('save', <<'__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw');
my $serialized_data = serialize();
my $final_state     = state();

my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

my $observed_state = `perl $temporary_filename state`;
chomp $observed_state;
if ($observed_state ne $final_state) {
  messages::error("The state of this object ($final_state) is inconsistent with the state of $temporary_filename ($observed_state).\n" .
                  "$0 has not been updated.");
} else {
  eval {file::write($0, $serialized_data)};
  warn $@ if $@;
  my $observed_self_state = `perl $0 state`;
  chomp $observed_self_state;
  unlink $temporary_filename if $observed_self_state eq $final_state;
}
__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw

meta::function('serialize', <<'__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw');
my @keys_without_internals = grep(!/^internal::/, sort keys %data);
join "\n", $data{'bootstrap::initialization'},
           (grep {$_} (map {serialize::single(@_)} grep(/^meta::/,  @keys_without_internals),
                                                   grep(!/^meta::/, @keys_without_internals),
                                                   grep(/^internal::/, sort keys %data))),
           "__END__";
__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw

meta::function('shell', <<'__6NZftjRE+lsE0a2W1BkCzwo78/IYQgOmo6CmA0BYozc');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = &{'api-name'}() . '$ ';
my $OUT = $term->OUT || \*STDOUT;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      my $result = eval {&{$function_name}(@args)};
      messages::warning($@) if $@;
      chomp $result;
      print $OUT $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  for my $watch (@{$transient{'watch_list'}}) {
    print $OUT eval($watch), "\n";
    print $OUT "Error evaluating watched expression $watch: $@\n" if $@;
  }

  $prompt = &{'api-name'}() . '$ ';
}
__6NZftjRE+lsE0a2W1BkCzwo78/IYQgOmo6CmA0BYozc

meta::function('size', <<'__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80');
length(serialize());
__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80

meta::function('snapshot', <<'__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0

meta::function('state', <<'__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI');
sha256_base64 serialize();
__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI

meta::function('unlock', <<'__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA

meta::function('usage', <<'__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I');
<<"EOD" . join '  ', split /\n/, ls ();
Usage: $0 [options] action [arguments]
Defined actions:
EOD
__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I

meta::function('vim', <<'__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for map {s/^vim_highlighter:://o; $_} grep /^vim_highlighter::/, sort keys %data;
__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec

meta::internal_function('associate', <<'__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless grep {$_ eq $namespace} @data_types;
$data{$name} = $value;
execute($name) if $options{'execute'};
__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0

meta::internal_function('basename', <<'__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw

meta::internal_function('execute', <<'__FfzmdPKSa4vnT4WNSN3uCxnwrUFKfkQbS6auoIa/SgE');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
carp $@ if $@ && $options{'carp'};
__FfzmdPKSa4vnT4WNSN3uCxnwrUFKfkQbS6auoIa/SgE

meta::internal_function('file::read', <<'__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg

meta::internal_function('file::write', <<'__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o

meta::internal_function('invoke_editor_on', <<'__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U');
my ($data, %options) = @_;
my $content_hash     = sha256_base64($data);
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my (undef, $filename) = tempfile("$0." . ("X" x 32), OPEN => 0);
$filename .= $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U

meta::internal_function('messages::error', <<'__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4');
my ($message) = @_;
die "$message\n";
__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4

meta::internal_function('messages::warning', <<'__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc');
my ($message) = @_;
print "$message\n";
__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc

meta::internal_function('namespace', <<'__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug

meta::internal_function('retrieve', <<'__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk');
my ($name) = @_;
$data{$name};
__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk

meta::internal_function('serialize::single', <<'__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = "__" . sha256_base64 $contents;
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE

meta::internal_function('state_based_filename', <<'__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw

meta::issue('bugs', <<'__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU');

__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU

meta::issue('test-cases', <<'__MXXSP54qIKQJy0L2vfZ/zMr5qgls+FTPZxXODvE+6ug');
Static importing
Document parsing and paragraph type detection
__MXXSP54qIKQJy0L2vfZ/zMr5qgls+FTPZxXODvE+6ug

meta::issue('todos', <<'__FSCz3NFg28ce9sd6amypBl2NWzpSY6d37dttfAhbg7A');
Add dependency processing
Unit testing framework image
Alternate symbol tables and environments
__FSCz3NFg28ce9sd6amypBl2NWzpSY6d37dttfAhbg7A

meta::library('datatypes', <<'__5/WXHaamE9qH4woaWyQnf+cVLgovlr7bUsR3yfN71iA');
# Data type definitions for the interpreter.

package types;

use Memoize;

my %symbol_table;

sub deftype {
  my ($name, %members) = @_;
  *{"types::$name"} = memoize(sub {bless $members{'new'}->(@_), $name});
  *{"${name}::$_"} = $members{$_} for keys %members;
}

my $id = sub {$_[0]};

sub method {
  my %table = @_;
  sub {
    my $self = $_[0];
    my $lambda_wrap = sub {lambda(sub {'(' . $self->serialize() . ' ' . $_[0] . ')'}, $_[1])};
    if (ref $_[1] eq 'symbol' && $table{${$_[1]}}) {
      # Default behavior -- return the value directly, wrapping it in a serializable lambda
      # closure only if it's a function.
      my $v = $table{${$_[1]}}->($self, $value);
      return $lambda_wrap->(${$_[1]}, $v) if ref $v eq 'CODE';
      return $v;
    } else {
      $table{''} ? $table{''}->($self, $_[1]) :
                   die 'Cannot apply ' . $self->serialize() . ' to ' . $_[1]->serialize();
    }
  };
}

deftype 'lambda', new       => sub {[@_]},
                  eval      => $id,
                  call      => sub {$_[0][1]->($_[1])},
                  serialize => memoize(sub {ref $_[0][0] eq 'CODE' ? $_[0][0]->() : $_[0][0]});

my $true  = lambda(sub {'true'},  sub {my $x = $_[0]; lambda(sub {'(true ' . $x->serialize() . ')'}, sub {$x->eval()})});
my $false = lambda(sub {'false'}, sub {lambda(sub {'(false ' . $_[0]->serialize() . ')'}, sub {$_[0]->eval()})});

deftype 'symbol',
  new       => sub {\$_[0]},
  eval      => sub {$symbol_table{${$_[0]}} ||
                    die 'Cannot evaluate symbol ' . $_[0]->serialize() . ' because it is undefined.'},

  bind      => sub {$symbol_table{${$_[0]}} = $_[1]; $_[0]},
  unbind    => sub {delete $symbol_table{${$_[0]}}; $_[0]},
  equals    => sub {ref $_[1] eq 'symbol' ? ${$_[0]} eq ${$_[1]} : ${$_[0]} eq $_[1]},
  call      => method(bind     => sub {my $self = $_[0]; sub {$self->bind($_[0]->eval())}},
                      'bound?' => sub {$symbol_table{${$_[0]}} ? $true : $false},
                      unbind   => sub {my $self = $_[0]; sub {$self->unbind(); $_[0]->eval()}},
                      value    => sub {$_[0]->eval()},
                      '<='     => sub {my $self = $_[0]; sub {$$self le ${$_[0]->eval()} ? $true : $false}},
                      '+'      => sub {my $self = $_[0]; sub {symbol($$self . ${$_[0]->eval()})}},
                      split    => sub {cons_from_array(map {symbol($_)} split //, ${$_[0]})},
                      ''       => sub {$_[1]->eval()->call($_[0])}),
  serialize => sub {${$_[0]}};

symbol('type')->bind(lambda('[type]', sub {symbol(ref $_[0]->eval())}));

my $gensym_count = 0;
sub gensym {
  my $value = $_[0]->eval();
  die 'Cannot call gensym on non-symbol value: ' . $value->serialize() unless ref $value eq 'symbol';
  ++$gensym_count;
  symbol("#$$value$gensym_count");
}

symbol('gensym')->bind(lambda('[gensym]', \&gensym));

deftype 'placeholder',
  new       => sub {\$_[0]},
  eval      => sub {${$_[0]}},
  call      => sub {method(unpack => sub {${$_[0]}},
                           ''     => sub {$_[1]->eval()->call(${$_[0]})})},
  serialize => sub {'[' . ${$_[0]}->serialize() . ']'};

symbol('placeholder')->bind(lambda('[placeholder]', sub {placeholder($_[0]->eval())}));

sub replace_in_form {
  my ($search, $replace, $x) = @_;
  return cons(replace_in_form($search, $replace, $x->[0]), replace_in_form($search, $replace, $x->[1])) if ref $x eq 'cons';
  return $x == $search || (ref $search eq 'symbol' && ref $x eq 'symbol' && $$search eq $$x) ? $replace : $x;
}
memoize('replace_in_form');

deftype 'expander', new => sub {[@_]},
                    eval => $id,
                    call => memoize(sub {
                      my ($placeholder, $form) = @{$_[0]};
                      my $value                = $_[1];
                      replace_in_form($placeholder, $value, $form);
                    }),
                    serialize => memoize(sub {
                      my ($placeholder, $form) = @{$_[0]};
                      '[' . $placeholder->serialize() . ' -> ' . $form->serialize() . ']';
                    });

deftype 'counter', new => sub {\$_[0]},
                   eval => sub {counter(${$_[0]} + 1)},
                   call => sub {die 'Cannot call ' . $_[0]->serialize() . ' on ' . $_[1]->serialize()},
                   serialize => sub {"[counter +${$_[0]}]"};

symbol('counter')->bind(counter(0));
symbol('trace')->bind(lambda('[trace]', sub {
  my $value = $_[0]->eval();
  print "  - \033[1;34m" . $_[0]->serialize() . "\033[0;0m\n";
  $value;
}));

symbol('beta')->bind(lambda('[beta]', memoize(sub {
  my $symbol = $_[0];
  die 'Cannot create beta-expander for non-symbol value ' . $symbol->serialize() unless ref $symbol eq 'symbol';
  lambda("[beta $$symbol -> ...]", memoize(sub {
    my $body        = $_[0];
    my $beta_symbol = symbol("β");
    my $placeholder = placeholder(gensym(placeholder($beta_symbol)));
    expander($placeholder, replace_in_form($symbol, $placeholder, $body));
  }, NORMALIZER => sub {$$symbol . "\n" . $_[0]->serialize()}));
})));

symbol('o\'')->bind(lambda('[o\']', memoize(sub {
  my $f = $_[0]->eval();
  lambda(sub {'(' . $f->serialize() . ' o\' ...)'}, memoize(sub {
    my $g = $_[0]->eval();
    lambda(sub {'(' . $f->serialize() . ' o\' ' . $g->serialize() . ')'}, sub {
      $f->call($g->call($_[0]));
    });
  }, NORMALIZER => sub {$f->serialize() . "\n" . $_[0]->serialize()}));
}, NORMALIZER => sub {$_[0]->serialize()})));

deftype 'cons', new       => sub {[$_[0], $_[1]]},
                eval      => sub {$_[0][0]->eval()->call($_[0][1])},
                head      => sub {$_[0][0]},
                tail      => sub {$_[0][1]},
                call      => method(head => sub {$_[0][0]},
                                    tail => sub {$_[0][1]},
                                    call => sub {my $self = $_[0]; sub {$_[0]->eval()->call($self->head())->call($self->tail())}},
                                    ''   => sub {$_[1]->eval()->call($_[0])}),
                serialize => memoize(sub {'(' . $_[0][0]->serialize() . ' . ' . $_[0][1]->serialize() . ')'});

symbol('cons')->bind(lambda('[cons]', sub {
  my $head = $_[0]->eval();
  lambda(sub {'(cons ' . $head->serialize() . ' ...)'}, sub {
    cons($head, $_[0]->eval());
  });
}));

sub cons_from_array {
  return nil() unless @_;
  my $tail = pop @_;
  return cons(cons_from_array(@_), $tail);
}

my $nil = '';
deftype 'nil', new       => sub {\$nil},
               eval      => $id,
               call      => sub {$_[1]->eval()},
               serialize => sub {':'};

symbol(':')->bind(nil());

sub number_op(&) {
  my $implementation = $_[0];
  sub {my $self = $_[0]; sub {number($implementation->($$self, ${$_[0]->eval()}))}}
}

deftype 'number', new       => sub {\$_[0]},
                  eval      => $id,
                  call      => method('<=' => sub {my $self = $_[0]; sub {$$self <= ${$_[0]->eval()} ? $true : $false}},
                                      '+'  => number_op {$_[0]  + $_[1]},
                                      '-'  => number_op {$_[0]  - $_[1]},
                                      '*'  => number_op {$_[0]  * $_[1]},
                                      '/'  => number_op {$_[0]  / $_[1]},
                                      '%'  => number_op {$_[0]  % $_[1]},
                                      '&'  => number_op {$_[0]  & $_[1]},
                                      '|'  => number_op {$_[0]  | $_[1]},
                                      '^'  => number_op {$_[0]  ^ $_[1]},
                                      '<<' => number_op {$_[0] << $_[1]},
                                      '>>' => number_op {$_[0] >> $_[1]},
                                      ''   => sub {return number(${$_[0]} * ${$_[1]}) if ref $_[1] eq 'number';
                                                   return $_[1]->eval()->call($_[0])}),
                  serialize => sub {${$_[0]}};

deftype 'file', new       => sub {\$_[0]},
                eval      => $id,
                call      => method(delete => sub {unlink ${$_[0]}->serialize() unless ref ${$_[0]} eq 'nil'; $_[0]},
                                    '<<'   => sub {my $self = $_[0]; sub {
                                                my $value = $_[0]->eval();
                                                my $output = ref $value eq 'number' ? chr $$value : $value->serialize();

                                                if (ref $$self eq 'nil') {
                                                  print STDOUT $output;
                                                } else {
                                                  open my $fh, '>>', $$self->serialize();
                                                  print $fh $output;
                                                  close $fh;
                                                }

                                                $self;
                                              }}),
                serialize => sub {'[file ' . ${$_[0]}->serialize() . ']'};

symbol('file')->bind(lambda('[file]', sub {file($_[0]->eval())}));
__5/WXHaamE9qH4woaWyQnf+cVLgovlr7bUsR3yfN71iA

meta::library('reader', <<'__4ziC8LosJk+o5rkVTM9RRiFyyI3ZtkpiIDmOz1M48uE');
package reader;

sub read_form {
  sub lex {
    grep length, split /([()])|\s+/o, $_[0];
  }

  sub parse {
    my ($value, $xs) = @_;
    my $x = shift @$xs;

    return $value                                                    if $x eq ')' || $x eq '';
    return parse(types::cons($value, parse(types::nil(), $xs)), $xs) if $x eq '(';
    return parse(types::cons($value, types::number($x)), $xs)        if $x =~ /^-?[\d.]+$/o;
    return parse(types::cons($value, types::symbol($x)), $xs);
  }

  parse types::nil(), [lex $_[0]];
}

sub read_paragraph {
  sub flatten_cons_tree {
    return () if ref $_[0] eq 'nil';
    return (flatten_cons_tree($_[0]->head()), $_[0]->tail());
  }

  return () if $_[0] =~ /^\s*[^( ]/o;
  return flatten_cons_tree(read_form $_[0]);
}

sub read_document {
  map {read_paragraph $_} split /\n\s*\n/o, $_[0];
}
__4ziC8LosJk+o5rkVTM9RRiFyyI3ZtkpiIDmOz1M48uE

meta::list('dependencies', <<'__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU');

__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU

meta::vim_highlighter('gnarly', <<'__907YJSe4mHsvUaHb4r7lOMbhUzzse46E7X3ozu4wrlQ');
" Gnarly
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   A minimalistic combinatory language with rewriting

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

set iskeyword=33-39,42-126,128-255

syn keyword gnarlyBuiltins         o' beta placeholder contained
syn keyword gnarlyMethods          bind unbind value head tail contained
syn keyword gnarlyFunctions        gensym counter trace type cons : contained
syn keyword gnarlyUserFunctions    ' '' :: o tr fn :< :> :<' :>' ::< ::> # '< '> '>' let en qn def contained
syn keyword gnarlyBooleans         k k' k: k:'
syn match   gnarlyNumbers          /\<-\?[0-9.]\+\>/ contained
syn match   gnarlyParens           /[()]/ contained

syn keyword gnarlyBooleanFunctions <= == < > >= != && \|\| ! contained
syn keyword gnarlyListFunctions    * / % ++ :? reverse reverse' contained
syn keyword gnarlyConditionals     cond contained

syn cluster gnarlySyntax add=gnarlyBuiltins,gnarlyMethods,gnarlyFunctions,gnarlyUserFunctions,gnarlyNumbers,gnarlyParens,gnarlyBooleans
syn cluster gnarlySyntax add=gnarlyBooleanFunctions,gnarlyListFunctions,gnarlyConditionals

syn region  gnarlyCodeRegion    start=/^\s*(/     end=/^$/ contains=@gnarlySyntax transparent fold
syn region  gnarlyCommentRegion start=/^\s*[^( ]/ end=/^$/ fold

hi link gnarlyBooleans         Boolean
hi link gnarlyBooleanFunctions Operator
hi link gnarlyListFunctions    Operator
hi link gnarlyCommentRegion    Comment
hi link gnarlyBuiltins         Keyword
hi link gnarlyFunctions        Keyword
hi link gnarlyConditionals     Keyword
hi link gnarlyMethods          Keyword
hi link gnarlyUserFunctions    Keyword
hi link gnarlyNumbers          Number
hi link gnarlyParens           Special

set foldmethod=syntax

let b:current_syntax = "gnarly"
__907YJSe4mHsvUaHb4r7lOMbhUzzse46E7X3ozu4wrlQ

meta::internal('runtime', <<'__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ');
my $initial_state = sha256_base64 serialize();

push @script_args, shift @ARGV while @ARGV && $ARGV[0] =~ /^-/;

my $default_action = retrieve('data::default-action');
chomp $default_action;
my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};
my $result = &{$function_name}(@ARGV);
chomp $result;
print "$result\n" if $result;

END {
  my $serialized_data = serialize();
  my $final_state     = sha256_base64 $serialized_data;
  save() unless $initial_state eq $final_state;
}

__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ

__END__