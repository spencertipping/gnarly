#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

$|++;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

meta::meta('datatypes::bootstrap', <<'__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM');
meta::define_form 'bootstrap', sub {};
__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM

meta::meta('datatypes::code_filter', <<'__gIaVDqDoWT04Y/vzEYyoyadmT36MLhB1ERa09udQZ9M');
meta::define_form 'code_filter', sub {
  my ($name, $value) = @_;
  *{"code_filter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__gIaVDqDoWT04Y/vzEYyoyadmT36MLhB1ERa09udQZ9M

meta::meta('datatypes::data', <<'__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U');
meta::define_form 'data', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "data::$name";
  *{$name} = sub {
    associate("data::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    retrieve("data::$name");
  };
};
__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U

meta::meta('datatypes::function', <<'__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0');
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "function::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0

meta::meta('datatypes::internal_function', <<'__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong');
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong

meta::meta('datatypes::line_filter', <<'__/k1BhEweDsgaEdqrALbIEjvKhsVrk/hv//e/KPydA6A');
meta::define_form 'line_filter', sub {
  my ($name, $value) = @_;
  *{"line_filter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__/k1BhEweDsgaEdqrALbIEjvKhsVrk/hv//e/KPydA6A

meta::meta('datatypes::note', <<'__TGOjJwmj+QJp1giUQqg2bEaQe8RvqnrFEqyZhIpSC34');
meta::define_form 'note', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "note::$name";
  *{$name} = sub {edit("note::$name")};
};
__TGOjJwmj+QJp1giUQqg2bEaQe8RvqnrFEqyZhIpSC34

meta::meta('datatypes::section', <<'__+sIaXu/jTubQJpv321ESZdZajbA4tb4E31KzSLZLA0c');
meta::define_form 'section', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "section::$name";

  my $stuff_to_eval = '';

  my @lines         = split /\n/, $value;
  my $in_code_piece = 0;
  my $spaces        = '';

  for (@lines) {
    s/^$spaces// if $in_code_piece;
    $in_code_piece &= ! /^\s*:.$/;
    $stuff_to_eval .= "$_\n" if $in_code_piece;
    $spaces = $1 if $in_code_piece |= /^(\s*)::$/;
  }

  eval $stuff_to_eval;
  carp $@ if $@;
};
__+sIaXu/jTubQJpv321ESZdZajbA4tb4E31KzSLZLA0c

meta::meta('datatypes::session', <<'__rDxpJZi2nnRrs0bEuCdBqYj6Oi9yGg51SB9r93gB18Y');
meta::define_form 'session', sub {};
__rDxpJZi2nnRrs0bEuCdBqYj6Oi9yGg51SB9r93gB18Y

meta::meta('datatypes::test', <<'__ueZczgsgipzDeioOy/gRBU5qUY/J01ZD6aS8UX0/cRY');
meta::define_form 'test', sub {
  my ($name, $value) = @_;

  my $stuff_to_eval = "sub {\n";
  my @lines         = split /\n/, $value;
  my $in_code_piece = 0;
  my $spaces        = '';

  for (@lines) {
    s/^$spaces// if $in_code_piece;
    $in_code_piece &= ! /^\s*:.$/;
    $stuff_to_eval .= "$_\n" if $in_code_piece;
    $spaces = $1 if $in_code_piece |= /^(\s*)::$/;
  }

  $stuff_to_eval .= "\n}";

  $transient{'tests'}{$name} = eval $stuff_to_eval;
  carp $@ if $@;
};
__ueZczgsgipzDeioOy/gRBU5qUY/J01ZD6aS8UX0/cRY

meta::meta('datatypes::unlit_converter', <<'__2X1thh9LQ0oUWCfeWj297YwiGJA/klB7hVI2sWEFtEE');
meta::define_form 'unlit_converter', sub {
  my ($name, $value) = @_;
  *{"unlit_converter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__2X1thh9LQ0oUWCfeWj297YwiGJA/klB7hVI2sWEFtEE

meta::meta('internal::runtime', <<'__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA');
meta::define_form 'internal', \&meta::meta::implementation;
__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA

meta::bootstrap('initialization', <<'__ynZW5t0TeKZlfH7tCNrNhNwdHJSP7ipCx9cfBgbVth8');
#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

$|++;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

__ynZW5t0TeKZlfH7tCNrNhNwdHJSP7ipCx9cfBgbVth8

meta::bootstrap('pod', <<'__Bu0JNmB4+PnXErSFUjITydzG9gUH+tOkN6A5eoIdd4A');

=head1 NAME

Literate Perl Project

=head1 SYNOPSYS

literate-perl-project new /filename/

/filename/ [action] [parameters]

=head1 DESCRIPTION

Stateful objects preserve their state between executions by rewriting themselves. Each time the script exits it replaces its contents with its new state. Thus
state management, for user-writable scripts, is completely transparent.

An object rewrites itself only if its state has changed. This may seem like a dangerous operation, but some checks are put into place to ensure that it goes
smoothly. First, the object is initially written to a separate file. Next, that file is executed and asked to provide a hashsum of its contents. The original
object is rewritten only if that hashsum is correct. This ensures that the replacement object is functional and has the right data.

Currently the only known way to lose your data is to edit the serialization-related functions in such a way that they no longer function. However, this is not
something most people will normally do. In the future there may be a locking mechanism to prevent unintentional edits of these attributes.

=head1 USAGE

A literate Perl project encapsulates a small development environment that can be useful for writing medium-sized Perl projects using a functional design
pattern. The code is divided into sections, each of which defines a top-level function of its name. So, for instance, C<section::example> defines a function
called C<example>. Code placed inside C<section::example> should be delimited by C<::> and C<:.>. Run this command:

  C<literate-perl-project cat section::assertions>

for an example of this coding style.

Other data types include tests, functions, data, and meta. These are described in more detail at http://spencertipping.com#self-modifying-perl.

=cut


__Bu0JNmB4+PnXErSFUjITydzG9gUH+tOkN6A5eoIdd4A

meta::code_filter('verbatim', <<'__Bzj2okFzY2S+MtaU5PusudWlHAmyV7DxiVVGO+wv3Nc');
my ($line, %settings) = @_;

unless ($settings{'name'}) {
  return '\begin{literatecode}' if $settings{'begin'};
  return '\end{literatecode}'   if $settings{'end'};
} else {
  return '\begin{examplecode}' if $settings{'name'} =~ /\sexample(\s|$)/ && $settings{'begin'};
  return '\end{examplecode}'   if $settings{'name'} =~ /\sexample(\s|$)/ && $settings{'end'};
}

return $line;
__Bzj2okFzY2S+MtaU5PusudWlHAmyV7DxiVVGO+wv3Nc

meta::data('default-action', <<'__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc');
shell
__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc

meta::data('document', <<'__88+b9fjpp/XfCv9UlGo7dU0etAKEofNyYMyx7Gmc4cU');
= Gnarly Programming Language
a Spencer Tipping
begin

- Introduction
  Gnarly is a minimalistic combinatory language with rewriting. This script provides a multi-session REPL, automatic image saving and loading, and the
  interpreter source code.
__88+b9fjpp/XfCv9UlGo7dU0etAKEofNyYMyx7Gmc4cU

meta::data('header', <<'__B8m9YZiGw2dspg9B3atiP1uO9NXiTc3IUTuQk8aYLWw');
\documentclass{article}
\usepackage{amsmath,amssymb,pxfonts,listings,color}
\usepackage[utf8]{inputenc}
\usepackage[colorlinks]{hyperref}

\definecolor{gray95}{rgb}{0.95,0.95,0.95}
\definecolor{slate}{rgb}{0.2,0.2,0.2}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{literatecode}
  {\lstset{frame=l,columns=fixed,basewidth=0.5em,numbers=left,language=perl,
           backgroundcolor=\color{gray95},basicstyle={\tt\scriptsize}}}
  {}

\lstnewenvironment{examplecode}
  {\lstset{frame=l,columns=fixed,basewidth=0.5em,
           basicstyle={\tt\scriptsize}}}
  {}
__B8m9YZiGw2dspg9B3atiP1uO9NXiTc3IUTuQk8aYLWw

meta::data('intro', <<'__uirjwqAxCBH+vu23aaPBO6uNM7a7cUHAYKJo8gIJsGw');
This is a TeX document generator.

If this is your first time using it, then you'll probably want to install
the VIM highlighter for the custom TeX format. To do that, run this:

  $ tex-document install-vim-highlighter

If you don't mind an extra line at the end of your .vimrc file, then you
can automatically associate .cltex files:

  $ tex-document update-vimrc

Now you're ready to go.

To create a new TeX document, do this:

  $ tex-document new newdoc

Next, edit the contents of your new document:

  $ ./newdoc e

Once you're done editing, you can build and display the document:

  $ ./newdoc make

Alternately, you can use the shell interface (exit with the 'exit' command or
control-D):

  $ ./newdoc shell
  tex-document$ e
  tex-document$ make
  ...
  tex-document$ ^D
  $

If you edit and run make a lot, I recommend you save your document just to be
on the safe side. Normally the document is not committed to disk until you exit
the shell, but you can commit at any time by using the 'save' command.

To extract your document in its original form, you can say this:

  $ ./newdoc document > file

And to extract the generated TeX:

  $ ./newdoc compile-to-tex > file
__uirjwqAxCBH+vu23aaPBO6uNM7a7cUHAYKJo8gIJsGw

meta::data('meta-associations', <<'__rP9455ERs+HDCFwK5CbemdmWivRRRDsaqzhK/4Of4ng');
^function:: .pl
^internal_function:: .pl
^meta:: .pl
^bootstrap:: .pl
^data::document$ .cltex
^data::.*vim-highlighter$ .vim
^unlit_converter:: .pl
^line_filter:: .pl
^code_filter:: .pl
^section:: .perltex
^session:: .gnarly
^test:: .perltex
__rP9455ERs+HDCFwK5CbemdmWivRRRDsaqzhK/4Of4ng

meta::data('name', <<'__ohnJGaQmJnPUNqX7FfcA/hxTRo3E78EirwEYNwcWx28');
repl
__ohnJGaQmJnPUNqX7FfcA/hxTRo3E78EirwEYNwcWx28

meta::data('output-dir', <<'__6WcazSRIScVxZ8ZY+i+Wl1IEj3qxhKPc9cRstNVq4SQ');
/tmp
__6WcazSRIScVxZ8ZY+i+Wl1IEj3qxhKPc9cRstNVq4SQ

meta::data('pdf-output-file', <<'__gFs2KtsORXD+oeALOmabA882HzsJc232N2yUGtuhtrQ');
/tmp/repl.raqzcPGKtsmTIbJkQXoJGWOrm7uuo+ozZkN5FeJT5D4/document.pdf
__gFs2KtsORXD+oeALOmabA882HzsJc232N2yUGtuhtrQ

meta::data('pdf-reader', <<'__BlFO10Obn0hAHVxLShDpKtlpv0BTeJ7iqm1v7vjCM+A');
evince
__BlFO10Obn0hAHVxLShDpKtlpv0BTeJ7iqm1v7vjCM+A

meta::data('pdftex', <<'__aHolEJEGN4wnHiydZyVzwRrETVuJhJOGo/nKL9tsLRY');
pdflatex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__
__aHolEJEGN4wnHiydZyVzwRrETVuJhJOGo/nKL9tsLRY

meta::data('session-vim-highlighter', <<'__0fBqY9Ub1J0e3m1QrDBRdfwS15sbEg9A8+SpNphM1IM');
" Gnarly
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   A minimalistic combinatory language with rewriting

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

set iskeyword=33-39,42-126,128-255

syn keyword gnarlyBuiltins      compose' eval beta placeholder
syn keyword gnarlyFunctions     bind gensym counter type <=
syn keyword gnarlyUserFunctions quote compose tr fn e< e> e<' e>' q> q>' e1 e1> quote2
syn region  gnarlyComments      start=/#/ end=/$/
syn match   gnarlyNumber        /\<-\?[0-9.]\+\>/
syn match   gnarlyParens        /[()]/

hi link gnarlyBuiltins      Keyword
hi link gnarlyFunctions     Type
hi link gnarlyUserFunctions Identifier
hi link gnarlyNumber        Number
hi link gnarlyComments      Comment
hi link gnarlyParens        Special

let b:current_syntax = "gnarly"
__0fBqY9Ub1J0e3m1QrDBRdfwS15sbEg9A8+SpNphM1IM

meta::data('table-of-contents', <<'__a4ayc/80/OGda4BO/1o/V0etpOqiLx1JwB5S3beHW0s');
1
__a4ayc/80/OGda4BO/1o/V0etpOqiLx1JwB5S3beHW0s

meta::data('tex', <<'__36pVFkgFfbTr/DrquMMaLrTY5F5S/VJ5Z3Jc90KC+q4');
latex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__
__36pVFkgFfbTr/DrquMMaLrTY5F5S/VJ5Z3Jc90KC+q4

meta::data('vim-highlighter', <<'__9M68+fUDGVDeeJP8SWHRqHPh2Bq1y6WM6Spq8bnK9yo');
" Cleaner TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   Cleaner TeX (a variant of LaTeX)

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn match  cltTitle   /^= .*$/
syn match  cltAuthor  /^a .*$/
syn match  cltDate    /^d .*$/
syn match  cltBegin   /^begin$/
syn match  cltSection /^\s*- .*$/
syn region cltVerbatim start=/^\s*::$/ end=/^\s*:\.$/

syn match  cltEnumeratedThing /^\s*[eid]\[/
syn match  cltEnumeratedThing /^\s*\][eid]/
syn match  cltItem            /^\s*+\s/
syn match  cltQuantifiedItem  /^\s*+\[[^\]]*\]\s/

runtime! syntax/tex.vim

hi link cltBegin    Keyword
hi link cltTitle    Identifier
hi link cltAuthor   Identifier
hi link cltDate     Identifier

hi link cltEnumeratedThing Special
hi link cltItem            Special
hi link cltQuantifiedItem  Special

hi link cltSection  Type

hi link cltVerbatim String

let b:current_syntax = "cltex"
__9M68+fUDGVDeeJP8SWHRqHPh2Bq1y6WM6Spq8bnK9yo

meta::function('add-to', <<'__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q');
my ($filename) = @_;
my @members = grep /^implementation::/, keys %data;

for (@members) {
  my $destination_name = basename($_);
  open my($handle), "| $filename import $destination_name" or messages::error("Attribute $_ could not be written.");
  print $handle retrieve($_);
  close $handle;
}
__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q

meta::function('cat', <<'__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk');
my ($name) = @_;
$data{$name};
__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk

meta::function('clean', <<'__YiaR22ZfeeFhhPYBUFHWBZqstuOzKtkv2XqmTuXhy1E');
my $output_directory = &{'pdf-output-file'}();
$output_directory =~ s+/.*++g;
unlink <$output_directory/*>;
rmdir $output_directory;
__YiaR22ZfeeFhhPYBUFHWBZqstuOzKtkv2XqmTuXhy1E

meta::function('clone', <<'__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY

meta::function('compile', <<'__HfmDCotLaO8/ha33D7dUqCAhPmSSrWt1lJc73NXcPz8');
my $tex_command         = tex();
my $pdftex_command      = pdftex();
my $filename            = 'document';

my $contents            = &{'compile-to-tex'}();
my $output_directory    = &{'output-dir'}();
chomp $output_directory;

my $temporary_directory = state_based_filename();
$temporary_directory =~ s+^.*/++;
$temporary_directory = "$output_directory/$temporary_directory";

$tex_command    =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$tex_command    =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

$pdftex_command =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$pdftex_command =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

mkdir $temporary_directory;
file::write("$temporary_directory/$filename.tex", $contents);

if (&{'table-of-contents'}()) {
  print "First invocation of TeX:\n";
  system($tex_command);
  print "Second invocation of TeX:\n";
  system($tex_command);
  print "PDFTeX:\n";
  system($pdftex_command);
} else {
  print "PDFTeX:\n";
  system($pdftex_command);
}

associate('data::pdf-output-file', my $result = "$temporary_directory/$filename.pdf", execute => 1);
$result;
__HfmDCotLaO8/ha33D7dUqCAhPmSSrWt1lJc73NXcPz8

meta::function('compile-to-tex', <<'__cvWyD1kaLfBVnSppeGw/hSpleoWxLARJQwP1tUKvebc');
my ($document) = document();
$document = &$_($document) for (grep /^unlit_converter::/, sort keys %data);
$document;
__cvWyD1kaLfBVnSppeGw/hSpleoWxLARJQwP1tUKvebc

meta::function('cp', <<'__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4

meta::function('create', <<'__4e/yca7FeKtJK0U61l9uCtsCPTiznglZlwh6U3iRLvY');
my ($name, $value) = @_;
messages::error("Attribute $name already exists.") if grep {$_ eq $name} keys %data;
associate($name, $value || join('', <STDIN>) || "\n");
__4e/yca7FeKtJK0U61l9uCtsCPTiznglZlwh6U3iRLvY

meta::function('e', <<'__VOcQy5WG275NZGlFODdYHYBe3oJ7/CHmTT/L9O1I6t0');
edit('data::document', extension => '.tex');
reload();
__VOcQy5WG275NZGlFODdYHYBe3oJ7/CHmTT/L9O1I6t0

meta::function('edit', <<'__rAkSOSll0evjt/D0qmnz2M++ACqz6cPtN8TLTHdQUJE');
my ($name, %options) = @_;

my $meta_extension = join '', grep {
  my $s = $_;
  $s =~ s/\s.*$//;
  $name =~ /$s/
} split /\n/, &{'meta-associations'}();

$meta_extension =~ s/^.*\s//;
chomp $meta_extension;

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $meta_extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
delete $data{$name} if length($data{$name}) == 0;

save();
__rAkSOSll0evjt/D0qmnz2M++ACqz6cPtN8TLTHdQUJE

meta::function('exists', <<'__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk');
my $name = shift;
grep {$_ eq $name} keys %data;
__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk

meta::function('externalize', <<'__jj0WxNMYD+Os9PnZiALK0NQjchmWBqx/IFg7n0I5qBg');
$externalized_functions{$_} = $_ for @_;
__jj0WxNMYD+Os9PnZiALK0NQjchmWBqx/IFg7n0I5qBg

meta::function('grab', <<'__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8');
my ($filename, @attribute_names) = @_;
associate("implementation::$_", `$filename cat $_`) for @attribute_names;
__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8

meta::function('i', <<'__QR51fAxT8uz7FCCErQfaHW/cnBqGJ5ftzao2gbDkiZY');
read_form($_[0])->serialize();
__QR51fAxT8uz7FCCErQfaHW/cnBqGJ5ftzao2gbDkiZY

meta::function('import', <<'__oK2Kj5RYHcEUK0Iyiqu8w7zipbg+QNF4VO4hm7BkUNA');
my ($name) = @_;
associate($name, join('', <STDIN>));
__oK2Kj5RYHcEUK0Iyiqu8w7zipbg+QNF4VO4hm7BkUNA

meta::function('install-vim-highlighter', <<'__TmVuhhK0m7hhHTY7P0vUg2SlzlvtVrYG1v7guGcBjG8');
my $home = $ENV{'HOME'};
mkdir "$home/.vim";
mkdir "$home/.vim/syntax";
file::write("$home/.vim/syntax/cltex.vim",  retrieve('data::vim-highlighter'));
file::write("$home/.vim/syntax/gnarly.vim", retrieve('data::session-vim-highlighter'));

<<"EOF";
The highlighter was created successfully. To have syntax highlighting activated
automatically, append this line to your .vimrc:

  au BufRead,BufNewFile *.cltex  set filetype=cltex
  au BufRead,BufNewFile *.gnarly set filetype=gnarly

Alternately, you can run $0 update-vimrc.
EOF
__TmVuhhK0m7hhHTY7P0vUg2SlzlvtVrYG1v7guGcBjG8

meta::function('lock', <<'__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y

meta::function('ls', <<'__M3wGXSw8/xm3RiNq0uLWke1dHm2OWQbvJpHkngdPafg');
join("\n", sort keys %externalized_functions);
__M3wGXSw8/xm3RiNq0uLWke1dHm2OWQbvJpHkngdPafg

meta::function('ls-a', <<'__6jKXRDXpIkzIOkcLtB2FOSTuZxqjBLyLZsF1vEmVn18');
join("\n", map {"  $_"} sort keys %data) . "\n";
__6jKXRDXpIkzIOkcLtB2FOSTuZxqjBLyLZsF1vEmVn18

meta::function('make', <<'__8mAUcwqcvcEhgs6tEjHaIx3uF9QOC+9DAI7NmulvJ74');
compile();
view();
clean();
__8mAUcwqcvcEhgs6tEjHaIx3uF9QOC+9DAI7NmulvJ74

meta::function('mv', <<'__PY7iwIY+6QtPN4V5hV4MOImRJVAKDkMmEKtkN34cv5Y');
my ($from, $to) = @_;
messages::error("The '$from' attribute does not exist.") unless grep $from, keys %data;
$data{$to} = $data{$from};
delete $data{$from};
__PY7iwIY+6QtPN4V5hV4MOImRJVAKDkMmEKtkN34cv5Y

meta::function('new', <<'__FQjehdFg7T3T2iHPMlGp6nAnrKAsQUIK5CXW02wNnos');
clone(@_);
__FQjehdFg7T3T2iHPMlGp6nAnrKAsQUIK5CXW02wNnos

meta::function('notes', <<'__9OB8og1t9W9mdqvF5+Zvbv1/z0k/IB2FIl7IL6MCfcs');
join "\n", grep /note::/, sort keys %data;
__9OB8og1t9W9mdqvF5+Zvbv1/z0k/IB2FIl7IL6MCfcs

meta::function('perl', <<'__XfLS9FlyE7w0CyERaGa/CTG/y2CrH4ZDN6M0SAM3IfY');
eval($_[0]);
print $@ if $@;
__XfLS9FlyE7w0CyERaGa/CTG/y2CrH4ZDN6M0SAM3IfY

meta::function('print_form', <<'__5cFh9FYVzT9rmQgSdQ/Qa8URqPX0/r86/ofI6sSWcgM');
read_form($_[0])->serialize()
__5cFh9FYVzT9rmQgSdQ/Qa8URqPX0/r86/ofI6sSWcgM

meta::function('pull', <<'__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg

meta::function('r', <<'__5CeQ2x3gMzUbczPItBKv5K1UZRnQKORZr6XbUudjDqk');
read_form($_[0])->eval()->serialize();
__5CeQ2x3gMzUbczPItBKv5K1UZRnQKORZr6XbUudjDqk

meta::function('reload', <<'__xKHcGZ482kA75f7C1RBqvd9EK/qvWTmQ1XZutdqgY0w');
execute($_) for grep ! /^internal::/ && ! /^bootstrap::/, sort keys %data;
__xKHcGZ482kA75f7C1RBqvd9EK/qvWTmQ1XZutdqgY0w

meta::function('repl', <<'__/j0R/Nqu8QbN5i3pVObJtgKa6SRtOoNME+HMBXLJI6A');
my ($name) = @_;

print "This session will not be stored.\nTo create or load a stored session, run repl <name>.\n" unless $name;

use Term::ReadLine;

my $term = new Term::ReadLine "$0 repl for $name";
$term->ornaments(0);
my $OUT = $term->OUT || \*STDOUT;

my $run_command = sub {
  my ($command) = @_;
  print "$command\n  | " . eval {read_form($command)->eval()->serialize()};
  chomp $@;
  print $@ ? $@ : '', "\n\n";
};

my $reload_session = sub {
  my ($name, %options) = @_;
  if ($name) {
    reload() unless $options{'no_reload'};
    print "Replaying commands...\n";
    my @commands = grep ! /^\s*#/, grep length, split /\n/, retrieve("session::$name");
    $run_command->($_) for @commands;
  }
};

$reload_session->($name);

print "Ready.\n";
my $prompt = $name ? $name . ' (repl)> ' : 'transient repl> ';
my @sessions;

while (defined ($_ = $term->readline($prompt))) {
  if (s/^\.//) {
    associate("session::$name", retrieve("session::$name") || '')         if $name;
    edit("session::$name"), $reload_session->($name, no_reload => 1)      if /^edit$/;
    edit("session::$_")                                                   if /^edit\s+(.*)$/ && s/^edit\s*//;
    push(@sessions, $name), $reload_session->($name = $_, no_reload => 1) if /^load\s*(.*)$/ && s/^load\s*//;
    $reload_session->($_, no_reload => 1)                                 if /^run\s*(.*)$/  && s/^run\s*//;
    $reload_session->($name = pop @sessions)                              if /^back\s*$/ && @sessions;
  } else {
    $run_command->($_) unless /^\s*#/;
    if ($name) {
      associate("session::$name", retrieve("session::$name") . "\n$_");
      save();
    }
  }

  $prompt = $name ? $name . ' (repl)> ' : 'transient repl> ';
}
__/j0R/Nqu8QbN5i3pVObJtgKa6SRtOoNME+HMBXLJI6A

meta::function('rm', <<'__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww

meta::function('save', <<'__HuNR2A6/zt/GGZDRiR1x82a4nBxpAlIR1QGc4kUySto');
my $serialized_data = serialize();
my $final_state     = state();

my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

my $observed_state = `perl $temporary_filename state`;
chomp $observed_state;
if ($observed_state ne $final_state) {
  messages::error("The state of this object ($final_state) is inconsistent with the state of $temporary_filename ($observed_state).\n" .
                  "$0 has not been updated.");
} else {
  file::write($0, $serialized_data);
  unlink $temporary_filename;
}
__HuNR2A6/zt/GGZDRiR1x82a4nBxpAlIR1QGc4kUySto

meta::function('serialize', <<'__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw');
my @keys_without_internals = grep(!/^internal::/, sort keys %data);
join "\n", $data{'bootstrap::initialization'},
           (grep {$_} (map {serialize::single(@_)} grep(/^meta::/,  @keys_without_internals),
                                                   grep(!/^meta::/, @keys_without_internals),
                                                   grep(/^internal::/, sort keys %data))),
           "__END__";
__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw

meta::function('shell', <<'__Xc/D1abI5xJTw6oyvavXrmS+ZaTDk09iQZEIvz8dWnc');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = name() . '$ ';
my $OUT = $term->OUT || \*STDOUT;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\")?")/;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/, s/\\\\"/"/g for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      my $result = eval {&{$function_name}(@args)};
      messages::warning($@) if $@;
      chomp $result;
      print $OUT $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  for my $watch (@{$transient{'watch_list'}}) {
    print $OUT eval($watch), "\n";
    print $OUT "Error evaluating watched expression $watch: $@\n" if $@;
  }

  $prompt = name() . '$ ';
}
__Xc/D1abI5xJTw6oyvavXrmS+ZaTDk09iQZEIvz8dWnc

meta::function('size', <<'__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80');
length(serialize());
__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80

meta::function('snapshot', <<'__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0

meta::function('state', <<'__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI');
sha256_base64 serialize();
__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI

meta::function('test', <<'__jDygB7Dk88JbeI6WiHxeHaoz3x6HcI3C4bg+8NXPKuE');
for (keys %{$transient{'tests'}}) {
  print "Running test $_\n";
  $transient{'tests'}{$_}->();
  print "\n";
}
__jDygB7Dk88JbeI6WiHxeHaoz3x6HcI3C4bg+8NXPKuE

meta::function('unlock', <<'__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA

meta::function('update-vimrc', <<'__u9D9zOyYETf+Potof5ijxSB/ripo6ZLAqt5LQifGyOc');
open my $fh, '>>', "$ENV{'HOME'}/.vimrc";
print $fh "\nau BufRead,BufNewFile *.cltex  set filetype=cltex";
print $fh "\nau BufRead,BufNewFile *.gnarly set filetype=gnarly";
close $fh;
__u9D9zOyYETf+Potof5ijxSB/ripo6ZLAqt5LQifGyOc

meta::function('usage', <<'__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I');
<<"EOD" . join '  ', split /\n/, ls ();
Usage: $0 [options] action [arguments]
Defined actions:
EOD
__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I

meta::function('view', <<'__wEtlK5H0ttR24UvcFUsgg5Es1V/VbjMJlU+SKiO2jKs');
my $pdf_reader      = &{'pdf-reader'}();
my $pdf_output_file = &{'pdf-output-file'}();
chomp $pdf_reader;
system("$pdf_reader '$pdf_output_file'");
__wEtlK5H0ttR24UvcFUsgg5Es1V/VbjMJlU+SKiO2jKs

meta::function('watch', <<'__dhD//JIeUty6psRafaNPVFHlY08V/gFhze8/CpWSbYw');
push @{$transient{'watch_list'}}, $_[0];
__dhD//JIeUty6psRafaNPVFHlY08V/gFhze8/CpWSbYw

meta::internal_function('associate', <<'__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless grep {$_ eq $namespace} @data_types;
$data{$name} = $value;
execute($name) if $options{'execute'};
__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0

meta::internal_function('basename', <<'__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw

meta::internal_function('execute', <<'__FfzmdPKSa4vnT4WNSN3uCxnwrUFKfkQbS6auoIa/SgE');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
carp $@ if $@ && $options{'carp'};
__FfzmdPKSa4vnT4WNSN3uCxnwrUFKfkQbS6auoIa/SgE

meta::internal_function('file::read', <<'__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg

meta::internal_function('file::write', <<'__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o

meta::internal_function('invoke_editor_on', <<'__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U');
my ($data, %options) = @_;
my $content_hash     = sha256_base64($data);
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my (undef, $filename) = tempfile("$0." . ("X" x 32), OPEN => 0);
$filename .= $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U

meta::internal_function('messages::error', <<'__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4');
my ($message) = @_;
die "$message\n";
__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4

meta::internal_function('messages::warning', <<'__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc');
my ($message) = @_;
print "$message\n";
__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc

meta::internal_function('namespace', <<'__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug

meta::internal_function('retrieve', <<'__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk');
my ($name) = @_;
$data{$name};
__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk

meta::internal_function('serialize::single', <<'__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = "__" . sha256_base64 $contents;
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE

meta::internal_function('state_based_filename', <<'__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw

meta::line_filter('convert_header_info', <<'__1jqqbjBcdOqh/3nTKZSDbW1AgEo4kg0dQ5HdRAgxyzE');
my ($line) = @_;

$line =~ s/^= (.*)$/\\title{$1}/;
$line =~ s/^a (.*)$/\\author{$1}/;
$line =~ s/^d (.*)$/\\date{$1}/;

my $document_header = '\begin{document}\maketitle';
$document_header .= '\tableofcontents' if &{'table-of-contents'}();

$line =~ s/^begin$/$document_header/;

$line;
__1jqqbjBcdOqh/3nTKZSDbW1AgEo4kg0dQ5HdRAgxyzE

meta::line_filter('convert_itemized_environments', <<'__crKVW6OfRA2nN2SGPWQ/DAD9NPUws+boS8dK4cf3X2I');
my ($line) = @_;

$line =~ s/^\s*\+ /\\item /;
$line =~ s/^\s*\+\[([^\]]*)\] /\\item[\1] /;

$line =~ s/^\s*e\[$/\\begin{enumerate}/;
$line =~ s/^\s*i\[$/\\begin{itemize}/;
$line =~ s/^\s*d\[$/\\begin{description}/;

$line =~ s/^\s*a\[$/\\begin{align*}/;

$line =~ s/^\s*\]e$/\\end{enumerate}/;
$line =~ s/^\s*\]i$/\\end{itemize}/;
$line =~ s/^\s*\]d$/\\end{description}/;

$line =~ s/^\s*\]a$/\\end{align*}/;

$line;
__crKVW6OfRA2nN2SGPWQ/DAD9NPUws+boS8dK4cf3X2I

meta::line_filter('convert_sections', <<'__lmhXPw+0a86ufxG3kCALtSl8Raqrt+7YZomx7zISUbw');
my ($line) = @_;

my %indentation_levels = (
  0 => '\section',
  2 => '\subsection',
  4 => '\subsubsection',
  6 => '\paragraph',
  8 => '\subparagraph');

if ($line =~ /^(\s*)- (.*)$/) {
  my $section = $indentation_levels{length($1)} || die "Invalid indentation level:\n$_";
  "${section} {${2}}";
} else {
  $line;
}
__lmhXPw+0a86ufxG3kCALtSl8Raqrt+7YZomx7zISUbw

meta::note('beta', <<'__myIEOiF7daqBFtiFvPvnxl+4ctOPbRghXEIob3SATbc');
[quote] macro bind ([e] ([e] ([beta] x) ([e] ([e] ([beta] f) ([e] ([beta] x f))))))
macro x+y (cons (x+y head tail) (x+y tail))
macro x+y (cons (x+y head tail) (x+y tail)) (5 6)
macro x+y ([quote] (cons (x+y head tail) (x+y tail))) (5 6)
macro x+y (cons (x+y head tail) (x+y tail)) (5 6)
macro x+y (cons : (cons (x+y head tail) (x+y tail))) (5 6)
macro x+y (cons (x+y head tail) (x+y tail)) y
macro x+y (cons (x+y head tail) (x+y tail))
macro x+y ([quote] x+y)
macro x+y ([quote] x+y) foo
macro x+y ([quote] x+y) (5 6)
macro x+y (cons ([quote] (x+y head tail)) ([quote] (x+y tail))) (5 6)
macro x+y (cons (([quote] x+y ([quote] head) ([quote] tail))) (([quote] x+y ([quote] tail)))) (5 6)
gensym
[quote] lambda bind (macro :parameter: (macro :body: (macro :argument: ([e] ([beta] :parameter: :body:) (macro :x: :x: :argument:))))
lambda x x
lambda x x 5
lambda x x y
lambda x x (cons 5 5)
lambda x (cons x x) (cons 5 5)
lambda x (cons x ([quote] y)) (cons 5 5)
lambda x (cons x ([quote] y)) ([quote] a)
lambda x (cons ([quote] x) ([quote] y)) ([quote] a)
lambda x (cons (x) ([quote] y)) ([quote] a)
lambda x (cons x ([quote] y)) ([quote] a)
lambda x (cons ([quote] y) ([quote] y)) ([quote] a)
lambda x (cons ([quote] y) ([quote] y)) a
lambda x (cons ([quote] y) ([quote] y)) (a a)
lambda x (cons ([quote] y) ([quote] y)) (5 5)
lambda x (cons ([quote] x) ([quote] y)) (5 5)
[quote] lambda bind (macro :parameter: (macro :body: (macro :argument: ([e] ([beta] :parameter: :body:) (macro :x: :x: :argument:))))
lambda x (cons ([quote] x) ([quote] y)) (5 5)
[quote] lambda bind (macro :parameter: (macro :body: (macro :argument: ([e] ([e] ([beta] :parameter: :body:) (macro :x: :x: :argument:)))))
lambda x (cons ([quote] x) ([quote] y)) (5 5)
[quote] lambda bind (macro :parameter: (macro :body: ([e] (macro :argument: ([e] ([beta] :parameter: :body:) (macro :x: :x: :argument:)))))
lambda x (cons ([quote] x) ([quote] y)) (5 5)
lambda x (cons ([quote] x) ([quote] y)) 5
[quote] lambda bind (macro :parameter: (macro :body: (macro :argument: ([e] ([beta] :parameter: :body:) (macro :x: :x: :argument:))))
lambda x (cons ([quote] x) ([quote] y)) 5
lambda x (cons ([quote] x) ([quote] y)) 5
[e] (lambda x (cons ([quote] x) ([quote] y)) 5)
[e] (lambda x (cons ([quote] x) ([quote] y)) 5) :
[e] (lambda x (cons ([quote] x) ([quote] y))) 5
lambda x (cons ([quote] x) ([quote] y)) 5
lambda x (cons x ([quote] y)) 5
lambda x (cons x ([quote] y)) a
lambda x (cons x ([quote] y)) (a a)
lambda x (cons x ([quote] y)) (cons a)
lambda x (cons x ([quote] y)) (cons a) head tail 5
lambda x (cons x ([quote] y)) (cons ([quote] a)) head tail 5
lambda x (cons x ([quote] y)) (cons ([quote] a)) head 5
lambda x (cons x ([quote] y)) (cons ([quote] a)) head
lambda x (cons x ([quote] y)) (cons ([quote] a))
lambda x (cons x ([quote] y)) (cons ([quote] a)) head
lambda x (cons x ([quote] y)) (cons ([quote] a)) head 5
(lambda x (lambda y (cons x y))) 5 6
(lambda x (lambda y (cons x y))) ([quote] x) ([quote] y)
(lambda x (lambda y (cons x y))) ([quote] y) ([quote] x)
(lambda x (lambda y (cons x y))) ([quote] y)
(lambda x (lambda y (cons x y))) ([quote] y) ([quote] x)
(lambda x (lambda y (cons x y))) ([quote] y) ([quote] x) :
(lambda x (lambda y (cons x y))) ([quote] y) ([quote] x)
(lambda x (lambda y (cons x y))) y
(lambda x (lambda y (cons x y))) y x
(lambda x (lambda y (cons x y))) 5 6
(lambda x (lambda y (cons x y))) 6 5
(lambda x (lambda y (cons x y))) ([quote] 6)
(lambda x (lambda y (cons x y))) ([quote] 6) ([quote] 5)
(lambda x (lambda y (cons x y))) ([quote] 6) ([quote] y)
(lambda x (lambda y (cons x y))) ([quote] 6) ([quote] x)
(lambda x (lambda y (cons x y))) ([quote] x) ([quote] x)
(lambda x (lambda y (cons x y))) ([quote] x) ([quote] y)
(lambda x (lambda y (cons x y))) ([quote] y) ([quote] y)
__myIEOiF7daqBFtiFvPvnxl+4ctOPbRghXEIob3SATbc

meta::note('combinators', <<'__t6QuV9bMoub9LXIIAdu1Ei5cLLJeoD9JWCsiWoYGkz4');
<- fn  ->
<- let <-
<- def (=> name (=> var (=> body (let name (fn var body

let l (c 1 (c 2 (c 3 (c 4 :
def count xs (? xs (c : (count (t xs))) :)
count l
__t6QuV9bMoub9LXIIAdu1Ei5cLLJeoD9JWCsiWoYGkz4

meta::note('compose', <<'__G6qVDMmEiKW+Mm05eHmJ1LQxkc5I66kCISBhL8lSHdo');
beta x x quote bind (beta x x)
quote e2 bind (compose eval eval)
quote e< bind (compose eval)
quote macro1 bind (e< (beta name (e< (beta expansion (compose eval (beta name expansion))))))
quote lambda1 bind (macro1 name (compose eval (compose (beta name) (compose quote eval))
lambda1
lambda1 x
lambda1 x x
quote lambda1 bind (macro1 name (beta expansion (compose eval (compose (beta name expansion) (compose quote eval))
lambda1 x x
quote lambda1 bind (macro1 name (macro1 expansion (compose eval (compose (beta name expansion) (compose quote eval))
lambda1 x x
quote lambda1 bind (macro1 expansion (compose eval (compose (beta _ expansion) (compose quote eval))
quote lambda1 bind (macro1 e (compose eval (compose (beta _ e) (compose quote eval))
quote (x (y x))
quote (x (y (x)))
quote (cons x x x)
quote ((cons x x) x)
(compose compose compose)
(compose compose compose) quote
(compose compose compose) quote quote quote
(compose compose compose) quote quote
(compose compose compose) quote quote quote
(compose compose compose) quote quote quote quote
(compose compose compose) quote quote quote quote quote
(compose compose compose)
(compose compose)
__G6qVDMmEiKW+Mm05eHmJ1LQxkc5I66kCISBhL8lSHdo

meta::note('debruijn', <<'__hE0jP/m0q08OBpEKT/ZLNC1Avae9X24xyVUdT5I2/Mw');
Using De Bruijn Indices
This has the problem that beta-reduction requires value conversion. "Free" references, that is, references which reach beyond immediate closures, need to have
their values incremented depending on the destination context of a substitution. So, for example:

  (λ λ 1 2) (λ 3)  =>  (λ (λ 4) ...)

or some such. In any case, this is far too counterintuitive for practical use and requires the β-expander to know something about lambdas.
__hE0jP/m0q08OBpEKT/ZLNC1Avae9X24xyVUdT5I2/Mw

meta::note('ebqe', <<'__/tHqPlHYmyvK2meWCvRJiNgEAQquH9Ukl/2tDKznhzM');

quote ec bind (ebqe f (ebqe x (eval (f x
quote macro bind (eval (beta x (ec (beta f
quote macro bind (eval (beta x (eval (beta f (eval (beta arg (eval (beta f x arg))
macro x x
quote macro bind (eval (beta x (beta f (beta arg (eval (beta f x arg))
macro x x
quote macro bind (eval (beta x (beta f (beta arg (beta f x arg))
macro x x
quote macro bind (beta x (eval (beta f (beta arg (beta f x arg))
macro x x
quote macro bind (beta x (beta f (beta arg (beta f x arg))
macro x x
quote macro bind (beta x (beta f (beta arg (beta x f arg
macro x x
quote macro bind (beta x (beta f (beta arg (beta x f arg
macro
macro x
quote macro bind (ec (beta x) (ec (beta f) (beta arg (beta x f arg
macro x
macro x x
quote macro bind (ec (ec beta))
macro x
macro
quote ec bind (ebqe f (eval ((beta x) (eval (f x
ec (beta x x)
ec (beta x x) 5
quote ec bind (ebqe f (eval (beta x)
ec (beta x x) 5
quote ec bind (ebqe f (eval (beta x x)
ec (beta x x) 5
ec (beta x x) y
quote ec bind (ebqe f (eval (eval (beta x x)
ec (beta x x) y
ec (ec (beta x x)) y
ec (ec (beta x)) x y
quote ec bind (ebqe f (eval (eval (beta x (f x)
ec (beta x x) y
quote ec bind (ebqe f (eval (beta x (eval (f x)
ec (beta x x) y
quote ec bind (ebqe f (eval (eval (beta x (eval (f x)
ec (beta x x) y
__/tHqPlHYmyvK2meWCvRJiNgEAQquH9Ukl/2tDKznhzM

meta::note('lambda', <<'__OI2fhJMiOIB+c4zEYXrG8t12DM2DNgdnhg2lqgFnY70');

(quote fn) bind (e (beta name) (e (beta expansion) (e (e (beta name expansion
fn x (x x)
(quote fn) bind (e (e (beta name) (e (beta expansion) (e (e (beta name expansion
fn x (x x)
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta name expansion
fn x (x x)
fn x (x x) 6
fn x (x x) (quote 6)
fn x (cons x x)
fn x (cons x x) 6
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (beta name expansion
fn x (cons x x) 6
fn x (cons x x) (quote foo)
(quote macro) bind (e (e (e (beta name) (e (e (beta expansion) (beta name expansion
(macro x x) 5
(macro x (cons x x)) cons
(quote macro) bind (e (e (e (e (beta name) (e (e (beta expansion) (beta name expansion
(macro x (cons x x)) cons
(quote macro) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e ((beta name expansion) value)
(macro x (cons x x)) cons
(quote macro) bind (e (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e ((beta name expansion) value)
(macro x (cons x x)) cons
(quote macro) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (e (beta name expansion) value)
(macro x (cons x x)) cons
(quote macro) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) value)
(macro x (cons x x)) cons
(macro x (cons x x)) beta
(macro x (x <= x)) bar
(macro x (x <= x)) (quote bar)
(macro x (x <= (quote x))) (quote bar)
(macro x ((quote x) <= (quote x))) bar
(macro x ((quote x) <= x)) bar
(quote def) bind (macro name (macro variable (macro expansion ((quote name) bind (fn variable expression)
def f x x
fn x x
fn x x 6
def f x
def f x x
(quote def) bind (macro name (macro variable (macro expansion ((quote name) bind (fn variable expansion)
def f x x
(quote def) bind (macro name (macro variable (macro expansion (name bind (fn variable expansion)
def f x x
def (quote f) x x
(quote def) bind (macro name (macro variable (macro expansion ((quote name) bind (fn variable expansion)
def (quote f) x x
def f x x
(quote let) bind (macro name (fn value ((quote name) bind value
let f (fn x x)
f
(macro q)
(macro q q)

(macro q q q)
(macro q q (quote q))
(quote macro) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value ((beta name expansion) value))
(macro q q (quote q))
(macro q q (quote a))
(quote let) bind (macro name (fn value ((quote name) bind value
let f (fn x x)
let : f (fn x x)
let f (fn x x)
(quote let) bind (fn name (fn value ((quote name) bind value
let (quote f) (fn x x)
let f (fn x x)
f
fn x x 6
fn x x q
(fn x x)
(fn x x) (quote a)
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value ((beta name expansion) value)
(fn x (quote x)) a
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) value)
(fn x (quote x)) a
(fn x (quote x)) (quote a)
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (beta value (e (beta name expansion) value)
(fn x (quote x)) (quote a)
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) value)
(fn x (quote x)) (quote a)
(fn x x) (quote a)
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name (quote expansion)) value)
(fn x x) (quote a)
(fn x (quote x)) (quote a)
e (fn x (quote x)) (quote a)
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e ((beta name expansion) value)
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) value)
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) value)
(fn x (quote x)) a
(fn x (quote x)) (quote a)
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) (quote value)
(fn x (quote x)) a
(quote id) bind (e (beta x x)
id (quote a)
id a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) (quote (id value)
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (e (beta name expansion) (quote (id value)
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) (e (quote (id value)
(fn x (quote x)) a
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (e (beta value (e (beta name expansion) (quote (id value
(fn x (quote x)) a
(fn x (quote x))
(fn x (quote x)) (quote a)
(fn x x) (quote a)
(quote fn) bind (e (e (beta name) (e (e (beta expansion) (e (e (beta value (e (beta name expansion) (quote (id value
(fn x x) (quote a)
(fn x (quote x)) (quote a)
(fn x (quote x)) a
__OI2fhJMiOIB+c4zEYXrG8t12DM2DNgdnhg2lqgFnY70

meta::note('lambda-new', <<'__AFkm6iYlZDKbysu0bnNRQzbr1cH2I7Uxp0XY5heFWQE');
' fun <- (' var => (' expansion => (-> var expansion
' def1 <- (' name => (' var => (' expansion => (' name <- (-> var expansion
' def2 <- (' name => (' var => (' expansion => (' name <- (fun var expansion
def1 inc1 x (c : x)
def2 inc2 x (c : x)
inc1 5
inc2 5
__AFkm6iYlZDKbysu0bnNRQzbr1cH2I7Uxp0XY5heFWQE

meta::note('macro', <<'__tbvmRqMrTORgyvH1tB2Dcg+LjbrhwtlvEwyl+Wa1L5A');
Macros don't do quite what you might expect. Because the body of a macro is unevaluated, currying macros is not very useful in most cases. Here's an example:

     (macro x (macro y (cons ([quote] x) ([quote] y)))) y x
  => (macro y (cons ([quote] y) ([quote] y))) x
  => (cons ([quote] x) ([quote] x))
  => (x . x)

There are cases where this would be useful, but what you really want is probably something more like this (remember that lists are consed in reverse):

     (macro x+y (cons (x+y head tail) (x+y tail))) (y x)
  => (cons ([-> (y x)] head tail) ([-> (y x)] tail))
  => (y . x)

Unfortunately, the same problem arises with lambdas. Because expressions are lazily evaluated (this is a property of using the eval-combinator), we have no way
of requiring that the inner lambda apply itself prior to finishing the beta-substitution. What we would really like is this series of events:

     (lambda x (lambda y (cons x y))) ([quote] y) ([quote] y)
  => (lambda y (cons [-placeholder containing [quote] y] y)) ([quote] y)
  => (cons [-placeholder containing [quote] y] [-placeholder containing [quote] y])
  => (y . y)

In other words, it would be nice to interrupt the beta-expansion by first replacing things with opaque placeholders and then finalizing the replacement with the
proper values. (This may be possible given the current architecture.)
__tbvmRqMrTORgyvH1tB2Dcg+LjbrhwtlvEwyl+Wa1L5A

meta::note('new', <<'__ljwh7tQAFuVbdTmNxkuqG9l92UCRcljXo/Z2x2sl/cI');
(quote beta') bind (e (beta x x))
beta' x x (quote a)
beta' 5
beta' (quote 5)
beta' (quote (quote 5))
beta (quote 5)
:
: (quote 5)
__ljwh7tQAFuVbdTmNxkuqG9l92UCRcljXo/Z2x2sl/cI

meta::note('scratchwork', <<'__LW36B2Xspo1k6IrRWwSMYA4V+z0NqpYFmQc6FQtRToI');
= Thoughts.

- Cons/eval
  Cons, if Church-encoded, doesn't have the correct semantics. E[(a.b)] should be E[a]b, but as it stands passing in the eval combinator would result in E[(a
  b)], which isn't right. In fact, there doesn't seem to be any way to achieve the right behavior unless we are guaranteed the presence of : at the beginning of
  a list; in that case, we'd have E[(: a)] = E[a], which kicks the process off. But that doesn't continue, so it's probably unproductive to consider this line
  of reasoning.

  Therefore it makes sense to represent cons cells as objects if we're using the eval combinator. Now if we're going to use a combinator that works properly,
  then I can imagine changing this...

  - Preserving Church-encoding with a proper combinator
    The semantics of a Church-encoded cons cell are:

      cons x y f = f x y

    So if we wanted our desired evaluation rule, then we'd need f to evaluate its first parameter by normal evaluation logic. So it wouldn't be an eval
    combinator; rather, it would be a simple evaluation function. This semantic works properly for cons cells, but fails elsewhere. For example, it then becomes
    impossible to multi-evaluate a form:

      e (e (cons x y)) => e (cons x y) => (x . y)

    So this line of reasoning is unproductive.

  - Using cons objects
    Cons works well as an object because we can treat it as callable anyway. For example, we could establish that:

      (x . y) 'head => x
      (x . y) 'tail => y
      (x . y) 'eval => E[x] y

    This provides a convenient way to deal with the fact that we've got something that isn't really a function but acts like one. I suppose by this definition
    /cons/ is a partial function that does the right thing. It could also know to apply its elements to a function that it is called on.

    The (x . y) 'eval case isn't degenerate. In reality, you'd write (x 'eval), where x is some cons-cell. In that case, you'd have the right result; x would be
    evaluated into the cons-cell that it represents, and 'eval would be called on it.
__LW36B2Xspo1k6IrRWwSMYA4V+z0NqpYFmQc6FQtRToI

meta::note('todo', <<'__QuvWyKwqOrlbLHIyGVUVDy5lEBMduQdOeic/GWQ4ujE');
Not sure yet
__QuvWyKwqOrlbLHIyGVUVDy5lEBMduQdOeic/GWQ4ujE

meta::note('twice', <<'__UjM+HJEP9B4gu5TweZO4pB36/jA4H17gBP55A4aZ39E');

'compose <- ('f -> ('('g -> ('('x -> ('(f (g x))))))))
compose ('x -> ('(h x))) ('x -> ('(c x x))) 5
'id <- ('x -> ('x))
'def <- ('name => ('('var => ('('body => ('('name <- ('var -> 'body))))))))
def f x x
'dup <- ('x -> ('(c x x)))
compose h dup
compose h dup 6
compose t dup 6
id 6
'k <- ('x -> ('('y -> ('x)))
k 5
k 5 8
k k 5
k k 5 8
k k 5 8 0
'; <- ('x -> ('('y -> ('y))))
; 5 6
'twice <- ('form => ('(; form form)))
twice 5
'n <- :
'inc <- ('('symbol => ('(symbol <- (c : symbol)))))
'inc <- ('symbol => ('(symbol <- (c : symbol))))
inc n
n
inc n
n
'inc <- ('symbol => ('(symbol <- (c : symbol
inc n
n
< ('n)
'inc <- ('(< ('symbol => ('(symbol <- (c : symbol
'inc <- ('symbol => ('(symbol <- (c : symbol
< (inc n)
< (inc n)
n
(inc n)
< 5
< ('n)
'inc <- ('symbol => ('(symbol <- (c : (< symbol
(inc n)
(inc n)
(inc n)
n
'n <- :
twice ('(inc n))
< (twice ('(inc n)))
< (twice (inc n))
n
< (twice (< (inc n)))
n
< (twice (< (inc n)))
n
'n <- :
< (twice (< (inc n)))
n
'n <- :
(twice x)
'twice <- ('form => ('(; (< form) (< form
(twice x)
(twice ('x))
n
< (twice (inc n))
n
'n <- :
< (twice (inc n))
< (twice (inc n))
< (twice (inc n))
n
'n <- :
n
(twice (inc n))
;
; (inc n) (inc n)
n
'n <- :
; (inc n) (inc n)
'n <- :
twice
twice ('f)
n
gensym :
mn
n
; n n
; ; n
; ; ;
; ; ; ; n
; ; ; n
; ; ; n n
n
twice (inc n)
n
'n <- :
< ('(compose h dup))
< ('(compose h dup)) 5
< ('(compose h dup 5))
< <
< (compose h dup)
< (compose h dup 5)
< (compose h dup)
< (compose h dup) x
< (compose h dup) ('x)
<
< ('(compose h dup))
< ('('(compose h dup)))
< ('(compose h dup))
< ('x)
< ('('x))
< ('(compose h dup))
< ('x)
< ('('x))
twice
twice ('x)
'!> <- ('var => ('('body -> ('('x => ('(< ((var => body) x)
'x !> ('x)
('x !> ('x)) 6
('x !> x) 6
'!> <- ('var => ('body -> ('x => (< ((var => body) x)
'!> <- ('('var => ('('body -> ('('x => ('(< ((var => body) x)
'!> <- ('var => ('('body -> ('('x => ('(< ((var => body) x)
('x !> x) 6
('x !> ('x)) 6
('x !> ('x))
'x !> ('x) 6
'x !> ('x) ('x)
'x !> x
'x !> x 6
'!> <- ('var => ('(body -> ('(x => ('(< ((var => body) x)
'x !> x 6
'!> <- ('var => ('('body -> ('('x => ('(< ((var => body) x)
'x !> x 6
'!> <- ('var => ('('body -> ('x => ('(< ((var => body) x)
'x !> x 6
'!> <- ('var => ('('body -> ('('x => (< ((var => body) x)
'x !> x 6
'!> <- ('var => ('('body -> ('('x => (< ('((var => body) x)
'x !> x 6
'!> <- ('var => ('('body -> ('('x => ('(< ((var => body) x)
'x !> x 6
'!> <- ('var => ('('body -> ('('x => ('(< ((var => body) x)
'!> <- ('var => ('('body -> ('('x => ('(< ((var => ('body)) x)
'x !> x 6
'!> <- ('var => ('('body -> ('('x => ('(< ((var => ('body)) ('x))
'x !> x 6
'!> <- ('var => ('('body -> ('('x => ('(< ((var => body) x)
reload
'x !> x 6
'x !> x
'x !> x c
'!> <- ('var => ('('body -> ('x => ('(< ((var => body) x)
'x !> x c
'!> <- ('var => ('body -> ('x => ('(< ((var => body) x)
'x !> x c
'!> <- ('var => ('('body -> ('('x => ('(< (((var) => (body)) x)
'x !> x c
'x !> x 9
'!> <- ('var => ('('body -> ('('x => ('(< ((< var => body) x)
'x !> x 9
'!> <- ('var => ('body -> ('x => (< ((var => body) x)
'x !> x
'x !> x 6
'!> <- ('var => ('body => ('x => (< ((var => body) x)
'x !> x 6
'!> <- ('var => ('body => ('x => (< ((< var => body) x)
'x !> x 6
!> x x
!> x x 7
('var => ('body => ('x => (< ((var => body) x)))))) 6
('var => ('body => ('x => (< ((var => body) x)))))) x x
('var => ('body => ('x => (< ((var => body) x)))))) x x 9
('var => ('body => ('x => (< ((var => body) x)))))) x x 9 0
('var => ('body => ('x => (< ((var => body) x))))) x x 9 0
('var => ('body => ('x => (< ((var => body) x))))) x x
('var => ('body => ('x => (< ((var => body) x))))) x x 0
('var => ('body => ('x => (< ((var => body) x))))) x x c
('var => ('body => ('x => (< ((var => body) x))))) x x
('var => ('body => ('x => (< ((var => body) x))))) x x 6
('var => ('body => ('x => (< ((var => body) x))))) y y 6
x
('var => ('body => ('x => (< ((var => body) x))))) ('x) ('x) 6
('var => ('body => ('x => (< ((var => body) x))))) e e 6
('var => ('body => ('x => (< ((('var) => body) x))))) e e 6
('var => ('body => ('x => (< ((('var) => body) x))))) e ('e) 6
('var => ('body => ('x => (< ((('var) => body) x))))) e ('('e)) 6
('var => ('body => ('x => (< ((('var) => body) x))))) e e 6
('var => ('body => ('x => (< ((('var) => body) x)))))) e e 6
('var => ('body => ('x => (< ((('var) => body) x))))) e e 6
('var => ('body => ('x => (< ((('var) => body) x))) e e 6
('var => ('body => ('x => (< ((('var) => body) x))))) e e 6
'!> <- ('var => ('body => ('x => (< ((('var) => body) x)))))
'x !> x
'x !> x 6
'e !> e 6
('x -> ('y -> (c x y))
'g <- ('x -> ('y -> (c x y))
g ('x) ('y)
g ('y) ('x)
->
y
('y)
('x)
x
__UjM+HJEP9B4gu5TweZO4pB36/jA4H17gBP55A4aZ39E

meta::section('00-unit-test-framework', <<'__jQTPs+xmTKvNE4yJQ+puEXddkY+waY2/ZIAOzvIp0E0');
- Unit Testing Framework
  - Assertions
    ::
    sub assert_base (&$) {
      my $thunk  = $_[0];
      my $result = eval {$thunk->()};
      print "| \033[1;31merror\033[0;0m in $_[1]: $@\n"    if     $@;
      print "| \033[1;31mfail\033[0;0m: $_[1] ($result)\n" if     $result;
      print "| \033[1;32mpass\033[0;0m: $_[1]\n"           unless $result;
    }

    sub assert (&$) {
      my $thunk = $_[0];
      assert_base {! $thunk->()} $_[1];
    }

    sub assert_equal {
      my ($v1, $v2, $name) = @_;
      assert_base {$v1 != $v2 && "$v1 != $v2"} $name;
    }

    sub assert_eq {
      my ($v1, $v2, $name) = @_;
      assert_base {$v1 ne $v2 && "$v1 ne $v2"} $name;
    }

    sub assert_isa {
      my ($value, $ref, $name) = @_;
      assert_base {ref($value) ne $ref and "ref $value ne $ref"} $name;
    }
    :.
__jQTPs+xmTKvNE4yJQ+puEXddkY+waY2/ZIAOzvIp0E0

meta::section('01-interpreter', <<'__Llh3j6PHxCa2O5VqjPtOYhHyyjrcYKNUaDPEldeykUU');
- Interpreter
  The interpreter provides semantics for expressions once they are in list form. Particularly, it does two things. First, it defines a global symbol table and a
  list of data types, and second it defines the two functions {\tt eval} and {\tt beta} that can be used to construct {\tt lambda} and other macros.

  - Bootstrap
    The symbol table is used/modified by programs. It stores both the API for working with symbols, and the global definitions that the program uses to run.

    ::
    my %symbol_table;
    :.

  - Data Types
    Here is a quick facility for defining interpreter data types:

    ::
    sub deftype {
      my ($name, %members) = @_;
      *{$name} = sub {bless $members{'new'}->(@_), $name};
      *{"${name}::$_"} = $members{$_} for keys %members;
      $symbol_table{"meta::$name"} = $members{'new'};
    }

    my $id = sub {$_[0]};
    :.

  - Primitive Types
    - Church-Encoded Booleans
      These aren't primitives, but they are used throughout the interpreter logic.

      ::
      deftype 'lambda', new       => sub {[@_]},
                        eval      => $id,
                        call      => sub {$_[0][1]->($_[1])},
                        serialize => sub {$_[0][0]};

      my $true  = lambda('true',  sub {my $x = $_[0];
                                       lambda('(true ' . $x->serialize() . ')', sub {$x})});
      my $false = lambda('false', sub {lambda('(false ' . $_[0]->serialize() . ')', sub {$_[0]})});
      :.

    - Symbols
      ::
      deftype 'symbol',
        new       => sub {\$_[0]},
        eval      => sub {$symbol_table{${$_[0]}} ||
                          die 'Cannot evaluate symbol ' . $_[0]->serialize() .
                              ' because it is undefined.'},

        bind      => sub {$symbol_table{${$_[0]}} = $_[1]; $_[0]},
        unbind    => sub {delete $symbol_table{${$_[0]}}; $_[0]},
        equals    => sub {ref $_[1] eq 'symbol' ? ${$_[0]} eq ${$_[1]} : ${$_[0]} eq $_[1]},
        call      => sub {
          my $self = $_[0];
          if (ref $_[1] eq 'symbol') {
            $_[1]->equals('bind')   ? lambda('(' . $_[0]->serialize() . ' bind)',
                                             sub {$self->bind($_[0]->eval())}) :
            $_[1]->equals('unbind') ? $_[0]->unbind() :
            $_[1]->equals('value')  ? $_[0]->eval() || nil() :
            $_[1]->equals('<=')     ? lambda('(' . $_[0]->serialize() . ' <=)',
                                             sub {
                                               my $rhs = $_[0];
                                               ref $rhs eq 'symbol' &&
                                                   ${$self} le ${rhs} ? $true : $false;
                                             }) :
            $_[1]->eval()->call($_[0]);
          } else {
            $_[1]->eval()->call($_[0]);
          }
        },
        serialize => sub {${$_[0]}};

      symbol('type')->bind(lambda('[type]', sub {symbol(ref $_[0]->eval())}));

      my $gensym_count = 0;
      sub gensym {
        my $value = $_[0]->eval();
        die 'Cannot call gensym on non-symbol value: ' . $value->serialize() unless ref $value eq 'symbol';
        ++$gensym_count;
        symbol("#$$value$gensym_count");
      }

      symbol('gensym')->bind(lambda('[gensym]', \&gensym));
      :.

    - Functions and Macros
      All callable things in this language are unary. The only difference between a function and a macro, then, is whether it evaluates its parameter. By
      default, $x$ calling $y$ doesn't say anything about whether $y$ gets evaluated -- this is a decision that $x$ makes. Also, there is no lexical scoping (or
      indeed scoping of any kind) built-in to the language, so there is no issue of evaluating symbols within their own context, etc. The same is true of
      macros, which decline to evaluate their forms.

      This paradigm makes an anonymous function and a macro much more similar to one another than they are in Common Lisp or Scheme. An anonymous function is,
      in a way, a code-expander just like a macro is; its form is replaced by a combinatory function that serves the same purpose. (In fact, the identity
      function and the identity macro are equivalent.) This transformation is done at interpretation-time as a macro-expansion. Thus the only internal
      difference between an anonymous function and a macro is the fact that an anonymous function receives the value of its parameter after evaluation, and a
      macro has no way of obtaining this value. Also, the output of a function is considered to have already been evaluated, whereas the output of a macro will
      be evaluated again. (See {\tt section::c2} for the definitions of {\tt macro} and {\tt lambda}.)

      ::
      deftype 'placeholder',
        new       => sub {\$_[0]},
        eval      => sub {${$_[0]}},
        call      => sub {die 'Cannot call ' . $_[0]->serialize() . ' on ' . $_[1]->serialize()},
        serialize => sub {'[' . ${$_[0]}->serialize() . ']'};

      symbol('placeholder')->bind(lambda('[placeholder]', sub {placeholder($_[0]->eval())}));

      sub map_form {
        my ($f, $x) = @_;
        return cons(map_form($f, $x->head()), map_form($f, $x->tail())) if ref $x eq 'cons';
        return $f->($x);
      }

      deftype 'expander', new => sub {[@_]},
                          eval => $id,
                          call => sub {
                            my ($placeholder, $form) = @{$_[0]};
                            my $value                = $_[1];
                            map_form(sub {$_[0] == $placeholder ? $value : $_[0]}, $form);
                          },
                          serialize => sub {
                            my ($placeholder, $form) = @{$_[0]};
                            '[' . $placeholder->serialize() . ' -> ' . $form->serialize() . ']';
                          };

      deftype 'counter', new => sub {\$_[0]},
                         eval => sub {counter(${$_[0]} + 1)},
                         call => sub {die 'Cannot call ' . $_[0]->serialize() . ' on ' . $_[1]->serialize()},
                         serialize => sub {"[counter +${$_[0]}]"};

      symbol('counter')->bind(counter(0));
      symbol('trace')->bind(lambda('[trace]', sub {
        my $value = $_[0]->eval();
        print "  - \033[1;34m" . $_[0]->serialize() . "\033[0;0m\n";
        $value;
      }));

      symbol('beta')->bind(lambda('[beta]', sub {
        my $symbol = $_[0];
        die 'Cannot create beta-expander for non-symbol value ' . $symbol->serialize() unless ref $symbol eq 'symbol';
        lambda('[beta ' . $symbol->serialize() . ' -> ...]', sub {
          my $body        = $_[0];
          my $beta_symbol = symbol("β");
          my $placeholder = placeholder(gensym(placeholder($beta_symbol)));
          expander($placeholder,
                   map_form(sub {$symbol->equals($_[0]) ? $placeholder : $_[0]}, $body));
        });
      }));

      symbol('eval')->bind(lambda('[eval]', sub {$_[0]->eval()->eval()}));
      symbol('compose\'')->bind(lambda('[compose\']', sub {
        my $f = $_[0]->eval();
        lambda('(' . $f->serialize() . ' o\' ...)', sub {
          my $g = $_[0]->eval();
          lambda('(' . $f->serialize() . ' o\' ' . $g->serialize() . ')', sub {
            $f->call($g->call($_[0]));
          });
        });
      }));
      :.

    - Cons Cells
      In the spirit of Lisp, expressions are consed into pairs. However, unlike Lisp the pairs are consed in reverse; that is, a list entered as {\tt (1 2 3)}
      will be consed as {\tt (((nil . 1) . 2) . 3)}. This allows for the unary cons-evaluation rule that $E[(a~.~b)] = E[a](b)$, provided that {\tt nil} behaves
      as the identity function (which it does).

      ::
      deftype 'cons', new       => sub {[$_[0], $_[1]]},
                      eval      => sub {$_[0]->head()->eval()->call($_[0]->tail())},
                      head      => sub {$_[0][0]},
                      tail      => sub {$_[0][1]},
                      call      => sub {
                        if (ref $_[1] eq 'symbol') {
                          return $_[0]->head() if $_[1]->equals('head');
                          return $_[0]->tail() if $_[1]->equals('tail');
                        } else {
                          die 'Cannot call ' . $_[0]->serialize() . ' on ' . $_[1]->serialize();
                        }
                      },
                      serialize => sub {'(' . $_[0]->head()->serialize() . ' . ' . $_[0]->tail()->serialize() . ')'};

      symbol('cons')->bind(lambda('[cons]', sub {
        my $head = $_[0];
        lambda('(cons ' . $head->serialize() . ')', sub {
          cons($head->eval(), $_[0]->eval());
        });
      }));

      my $nil = '';
      deftype 'nil', new       => sub {\$nil},
                     eval      => $id,
                     call      => sub {$_[1]->eval()},
                     serialize => sub {':'};

      symbol(':')->bind(nil());
      :.

    - Numbers
      ::
      deftype 'number', new       => sub {\$_[0]},
                        eval      => $id,
                        call      => sub {die 'Cannot call ' . $_[0]->serialize() . ' on ' . $_[1]->serialize ()},
                        serialize => sub {${$_[0]}};
      :.
__Llh3j6PHxCa2O5VqjPtOYhHyyjrcYKNUaDPEldeykUU

meta::section('02-reader', <<'__uWY6YvyzhY3xXWMIVwuABeLLMHRR7Is6podZsCSToro');
- Reader
  The reader is actually quite simple. All it needs to do is split its input at two levels and then construct cons cells:

  ::
  sub read_form {
    sub lex {
      grep length, split /([()])|\s+/, $_[0];
    }

    sub parse {
      my ($value, $xs) = @_;
      my $x = shift @$xs;

      return $value                                      if $x eq ')' || $x eq '' || $x =~ /^#/;
      return parse(cons($value, parse(nil(), $xs)), $xs) if $x eq '(';
      return parse(cons($value, number($x)), $xs)        if $x =~ /^-?[\d.]+$/;
      return parse(cons($value, symbol($x)), $xs);
    }

    parse nil(), [lex $_[0]];
  }
  :.

  Right now there is no notion of read-macros. This is probably sufficient given that we can go through the form after the fact and reconstruct stuff. It also
  keeps the reader code very simple, as above.
__uWY6YvyzhY3xXWMIVwuABeLLMHRR7Is6podZsCSToro

meta::session('c2', <<'__H2XcMWeZdjVLsYhuwspPdZdplYkFTkd1ohWPNsjr680');
# Define quote. This is a rewrite from a form to itself, which will absorb one eval. quote2 is like quote, but useful for functions instead of rewriting.
beta _ _ quote  bind (beta _ _)
quote    quote2 bind (beta _ (quote _))

# Composition of functions. This is different from composition of macros because the output from the rightmost function must be protected from the evaluator on
# the leftmost function. This requires quoting it.
quote compose bind (compose' eval (beta _ (compose' (compose' _ quote2))))

quote e1  bind (compose eval quote)

quote e<  bind (compose eval)
quote e>  bind (e< (beta _ (compose _ eval)))
quote q>  bind (e< (beta _ (compose _ quote)))

quote e<' bind (compose' eval)
quote e>' bind (e< (beta _ (compose' _ eval)))
quote q>' bind (e< (beta _ (compose' _ quote)))
quote e1> bind (e< (beta _ (compose  _ e1)))

quote tr bind (e< (e>' (beta ev (e< (beta name (e< (beta ev (e< (beta name ev)))))))) (quote (gensym (quote γ))))
quote fn bind (e>' (tr ev (tr name (tr ev (compose' (e< (beta name ev)) placeholder)))) (quote (gensym (quote λ))))
__H2XcMWeZdjVLsYhuwspPdZdplYkFTkd1ohWPNsjr680

meta::session('tc2', <<'__eP5i44shT676QnQwP9eaeY4nRMzD2jMb6BqtCAEAYvM');
# Macro tests
tr ev
tr ev ev
tr name
tr name name
tr x (cons x x)
tr x (cons x x) eval
tr x (cons (quote x) (quote x))
tr x (cons (quote x) (quote x)) eval

tr x (tr y (cons x y)) y
tr x (tr y (cons x y)) y x
tr x (tr y (cons (quote x) (quote y))) y x

# Lambda tests
fn _ _ (quote foo)
fn _ (eval _) (quote (quote foo))
fn x (fn y (cons x y))
fn x (fn y (cons x y)) 5 6
fn x (fn y (cons x y)) (quote foo) (quote bar)
fn x (fn y (cons x y)) (quote x) (quote y)
fn x (fn y (cons x y)) (quote y) (quote x)
fn x
fn x x
fn name
fn name name
fn ev
fn ev ev

fn x (fn y (cons x y)) (quote y)
fn x (fn y (cons x y)) (quote x)

# Form inspection
tr
fn
fn foo foo 5
fn foo foo counter
fn x x x
fn x x (quote x)
fn x x
__eP5i44shT676QnQwP9eaeY4nRMzD2jMb6BqtCAEAYvM

meta::test('interpreter', <<'__IiZY1aPMuTta05D2n9j2mPQ7+as2p9p2pnuiXmn4KV0');
- Interpreter Unit Tests
  These tests depend on both the interpreter logic and the initial bindings.

  ::
  assert_equal cons(2, 3)->head(), 2, 'cons::head';
  assert_equal cons(2, 3)->tail(), 3, 'cons::tail';

  assert_isa quote(cons(2, 3))->eval(), 'cons',   'quote::eval cons';
  assert_isa quote(number(3))->eval(),  'number', 'quote::eval number';

  assert_equal quote(cons(2, 3))->eval()->head(), 2, 'quote->cons->head';
  :.

  - Functions and Macros
    Tests for functions and macros -- basically, we need to make sure that certain things get evaluated and other things don't. Whether or not they get
    evaluated depends on whether the left-hand side chooses to evaluate its parameter. (So functions are actually a special-case of macros that evaluate their
    parameters.)

    ::
    assert {cons(lambda(sub {$_[0] + 1}), undef)->head()->eval()}              'cons lambda head eval';
    assert {cons(lambda(sub {$_[0] + 1}), undef)->head()->call(quote(2)) == 3} 'cons lambda head eval call';

    assert_equal cons(symbol('h'), quote(cons(2, 3)))->eval(), 2, "(h '(2 . 3))";
    assert_equal cons(symbol('t'), quote(cons(2, 3)))->eval(), 3, "(t '(2 . 3))";

    assert_eq cons(nil(), quote(number(2)))->eval()->serialize(), 2, "(: . 'x) => x";

    assert_eq cons(cons(nil(), symbol('h')),
                   cons(cons(nil(), symbol('quote')), cons(cons(nil(), number(2)), number(3))))->eval()->serialize(), '(: . 2)', "(h '(2 . 3)) live";
    :.
__IiZY1aPMuTta05D2n9j2mPQ7+as2p9p2pnuiXmn4KV0

meta::test('reader', <<'__nf6ljIEkUEFjgbnLIw9WCNXSXSmD+SDqBpjNdZBUz7U');
- Reader Unit Tests
  ::
  assert_isa read_form('foo')->tail(), 'symbol', 'read_form foo tail';
  assert_isa read_form('foo')->head(), 'nil',    'read_form foo head';

  assert_isa read_form('foo bar')->tail(),         'symbol', 'read_form foo bar tail';
  assert_isa read_form('foo bar')->head(),         'cons',   'read_form foo bar head';
  assert_isa read_form('foo bar')->head()->tail(), 'symbol', 'read_form foo bar head tail';

  assert_isa read_form('(x)')->tail(), 'cons',   'read_form (x) tail';
  assert_isa read_form('(x)')->head(), 'nil',    'read_form (x) head';

  assert_eq read_form('foo bar (bif baz)')->serialize(), '(((: . foo) . bar) . ((: . bif) . baz))', 'read_form foo bar (bif baz)';
  :.
__nf6ljIEkUEFjgbnLIw9WCNXSXSmD+SDqBpjNdZBUz7U

meta::unlit_converter('create_sections', <<'__3B8xPfI6sd/h5qx4VCgsXNpNnGyHsVGdHsAwUWihmXw');
my ($document) = @_;
$document .= "\n" . retrieve($_) . "\n" for (grep /^section::/ || /^test::/, sort keys %data);
$document;
__3B8xPfI6sd/h5qx4VCgsXNpNnGyHsVGdHsAwUWihmXw

meta::unlit_converter('main', <<'__3D082OWBmT2cWw4D6ktyDGp1MHknawaTDW2B0gvZPyM');
my ($document) = @_;

my $sections_already_encountered = 0;
my $inside_code_block            = 0;
my $code_block_indentation       = 0;
my $code_section_name            = '';
my $result                       = '';

for (split /\n/, $document) {
  # Handle code blocks.
  if (/^(\s*):\.$/) {
    $inside_code_block = $code_block_indentation = 0;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, end => 1);
    }
  }

  if ($inside_code_block) {
    my $spaces_to_delete = ' ' x $code_block_indentation;
    s/^$spaces_to_delete//;
    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation);
    }
  } else {
    for my $filter_name (grep /^line_filter::/, sort keys %data) {
      $_ = &$filter_name($_);
    }
  }

  if (/^(\s*)::(\s.*)?$/) {
    $inside_code_block      = 1;
    $code_block_indentation = length($1);
    $code_section_name      = $2;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, begin => 1);
    }
  }

  $result .= "$_\n";
}

$result;
__3D082OWBmT2cWw4D6ktyDGp1MHknawaTDW2B0gvZPyM

meta::unlit_converter('zz_append_footer', <<'__xZrf+gAwEiK7btRcm+mwC/qtHsXp2FQ/Z8ZCwMvSw4Q');
my ($document) = @_;
"$document\n\\end{document}";
__xZrf+gAwEiK7btRcm+mwC/qtHsXp2FQ/Z8ZCwMvSw4Q

meta::unlit_converter('zz_prepend_header', <<'__4YCmTeTBS/MGOkeIFkQRlLujLJ1g/qS0/0iCeanWkkw');
my ($document) = @_;
header() . "\n$document";
__4YCmTeTBS/MGOkeIFkQRlLujLJ1g/qS0/0iCeanWkkw

meta::internal('runtime', <<'__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ');
my $initial_state = sha256_base64 serialize();

push @script_args, shift @ARGV while @ARGV && $ARGV[0] =~ /^-/;

my $default_action = retrieve('data::default-action');
chomp $default_action;
my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};
my $result = &{$function_name}(@ARGV);
chomp $result;
print "$result\n" if $result;

END {
  my $serialized_data = serialize();
  my $final_state     = sha256_base64 $serialized_data;
  save() unless $initial_state eq $final_state;
}

__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ

__END__